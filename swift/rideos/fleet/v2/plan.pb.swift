// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rideos/fleet/v2/plan.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2018-2019 rideOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Rideos_Fleet_V2_GetPlanRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vehicles for which to provide plan recommendations. 
  /// Map from vehicle identifier to `Vehicle` object.
  public var vehicles: Dictionary<String,Rideos_Fleet_V2_Vehicle> = [:]

  /// Tasks that the vehicles should service. Should include both tasks that are reflected in the current
  /// vehicle plans, as well as new tasks that need to be incorporated into vehicle plans. Map from task identifier to `Task` object.
  public var tasks: Dictionary<String,Rideos_Fleet_V2_Task> = [:]

  /// If true, the inital plan may have tasks reassigned to new vehicles when doing so provides a better solution.
  public var allowVehicleReassignment: Bool = false

  /// Specifies the optimization profile to use within the fleet planning algorithm.
  public var optimizeFor: Rideos_FleetPlannerCommons_OptimizationProfile = .default

  public var etaPredictionType: Rideos_FleetPlannerCommons_EtaPredictionType = .realTimeTraffic

  /// If provided, this will add an additional step in the response for the amount of time it takes to service
  /// the dropoff.
  public var includeServicingDropoffStepInPlan: Bool = false

  /// Should only be set if allow_vehicle_reassignments is set to true.
  /// Provides configuration to fine tune vehicle reassignments.
  public var vehicleReassignmentConfiguration: Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration {
    get {return _vehicleReassignmentConfiguration ?? Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration()}
    set {_vehicleReassignmentConfiguration = newValue}
  }
  /// Returns true if `vehicleReassignmentConfiguration` has been explicitly set.
  public var hasVehicleReassignmentConfiguration: Bool {return self._vehicleReassignmentConfiguration != nil}
  /// Clears the value of `vehicleReassignmentConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearVehicleReassignmentConfiguration() {self._vehicleReassignmentConfiguration = nil}

  /// If provided, this will add an additional step in the response for the amount of time it takes to service
  /// the pickup.
  public var includeServicingPickupStepInPlan: Bool = false

  /// Defines properties for each resource referenced within the request.
  public var resource: [Rideos_FleetPlannerCommons_Resource] = []

  public var allowOutOfBoundsAssignments: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vehicleReassignmentConfiguration: Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration? = nil
}

public struct Rideos_Fleet_V2_GetPlanResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recommended plan for each vehicle.
  public var recommendations: [Rideos_Fleet_V2_VehiclePlanRecommendation] = []

  /// Tasks that could not be solved for.
  public var unresolvedTasks: [Rideos_Fleet_V2_UnresolvedTask] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Unresolved task
public struct Rideos_Fleet_V2_UnresolvedTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id for the unresolved task.
  public var taskID: String = String()

  /// One or more reasons why the task was not resolved (not in any particular order) along with the number of vehicles
  /// that match that reason. If a vehicle is not able to satisfy the given task for more than one reason then it will
  /// be included in the vehicle_count for each applicable reason.
  /// i.e. For vehicles V1 and V2, if a task T is unresolved because neither has enough capacity and V2 is excluded
  /// for T, there will be two UnresolvedReasons:
  ///   1) VEHICLES_WITH_LOW_CAPACITY with vehicle_count 2
  ///   2) VEHICLES_EXCLUDED with vehicle_count 1
  /// For vehicles where none of the known Type is applicable, the unresolvable_reason_type will be set to UNKNOWN and
  /// the vehicle_count set to the number of such vehicles.
  public var unresolvableReason: [Rideos_FleetPlannerCommons_UnresolvableReason] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Vehicle
public struct Rideos_Fleet_V2_Vehicle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The vehicle's position.
  public var position: Rideos_Geo_V1_Position {
    get {return _storage._position ?? Rideos_Geo_V1_Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {_uniqueStorage()._position = nil}

  /// The vehicle's heading.
  /// Measured clockwise from true North - i.e. 0 is true North, 90 is East, 180 is South, 270 is West, etc..
  public var heading: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _storage._heading ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_uniqueStorage()._heading = newValue}
  }
  /// Returns true if `heading` has been explicitly set.
  public var hasHeading: Bool {return _storage._heading != nil}
  /// Clears the value of `heading`. Subsequent reads from it will return its default value.
  public mutating func clearHeading() {_uniqueStorage()._heading = nil}

  /// The total resource capacity in the vehicle. ex: if the vehicles are transporting passengers, this might be
  /// the number of seats in the vehicle. Each Task should indicate the number of resources required - i.e. the number
  /// of resources that are consumed when the vehicle completes the Task's pickup step and released when the vehicle
  /// completes the Task's dropoff step.
  public var resourceCapacity: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._resourceCapacity ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._resourceCapacity = newValue}
  }
  /// Returns true if `resourceCapacity` has been explicitly set.
  public var hasResourceCapacity: Bool {return _storage._resourceCapacity != nil}
  /// Clears the value of `resourceCapacity`. Subsequent reads from it will return its default value.
  public mutating func clearResourceCapacity() {_uniqueStorage()._resourceCapacity = nil}

  /// Maximum capacity of the vehicle by CapacityImpact type.
  public var capacity: [Rideos_FleetPlannerCommons_CapacityLimit] {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  /// Current inventory of the vehicle by Resource type.
  public var inventory: [Rideos_FleetPlannerCommons_ResourceAndCount] {
    get {return _storage._inventory}
    set {_uniqueStorage()._inventory = newValue}
  }

  /// The vehicle's current plan.
  public var currentPlan: Rideos_Fleet_V2_VehiclePlan {
    get {return _storage._currentPlan ?? Rideos_Fleet_V2_VehiclePlan()}
    set {_uniqueStorage()._currentPlan = newValue}
  }
  /// Returns true if `currentPlan` has been explicitly set.
  public var hasCurrentPlan: Bool {return _storage._currentPlan != nil}
  /// Clears the value of `currentPlan`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPlan() {_uniqueStorage()._currentPlan = nil}

  /// Identifier of the vehicle.
  public var vehicleID: String {
    get {return _storage._vehicleID}
    set {_uniqueStorage()._vehicleID = newValue}
  }

  public var restrictTaskInsertionsUpTo: UInt32 {
    get {return _storage._restrictTaskInsertionsUpTo}
    set {_uniqueStorage()._restrictTaskInsertionsUpTo = newValue}
  }

  /// Specify vehicle-specific constraints directly.
  /// Can not be used at the same time as specifying a `routingProfileId`.
  public var routingConstraints: Rideos_Fleet_V2_Vehicle.RoutingConstraints {
    get {return _storage._routingConstraints ?? Rideos_Fleet_V2_Vehicle.RoutingConstraints()}
    set {_uniqueStorage()._routingConstraints = newValue}
  }
  /// Returns true if `routingConstraints` has been explicitly set.
  public var hasRoutingConstraints: Bool {return _storage._routingConstraints != nil}
  /// Clears the value of `routingConstraints`. Subsequent reads from it will return its default value.
  public mutating func clearRoutingConstraints() {_uniqueStorage()._routingConstraints = nil}

  /// Time window representing the expected start and end time for a vehicle shift.
  public var shiftTimeWindow: Rideos_Fleet_V2_TimeWindow {
    get {return _storage._shiftTimeWindow ?? Rideos_Fleet_V2_TimeWindow()}
    set {_uniqueStorage()._shiftTimeWindow = newValue}
  }
  /// Returns true if `shiftTimeWindow` has been explicitly set.
  public var hasShiftTimeWindow: Bool {return _storage._shiftTimeWindow != nil}
  /// Clears the value of `shiftTimeWindow`. Subsequent reads from it will return its default value.
  public mutating func clearShiftTimeWindow() {_uniqueStorage()._shiftTimeWindow = nil}

  /// Optional: routing profile ID to be applied to the vehicle's routes.
  /// Cannot be used at the same time as `routingConstraints`.
  /// New profiles can be added and updated via the Routing Profile API.
  public var routingProfileID: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._routingProfileID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._routingProfileID = newValue}
  }
  /// Returns true if `routingProfileID` has been explicitly set.
  public var hasRoutingProfileID: Bool {return _storage._routingProfileID != nil}
  /// Clears the value of `routingProfileID`. Subsequent reads from it will return its default value.
  public mutating func clearRoutingProfileID() {_uniqueStorage()._routingProfileID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct RoutingConstraints {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var blacklistConstraintID: [String] = []

    public var whitelistConstraintID: [String] = []

    /// Optional: the returned plan will not require the vehicle to traverse these avoid constraints. Avoid constraints
    /// take precedence over operational constraints if both are specified.
    public var avoidConstraintID: [String] = []

    /// Optional: if provided, this list of identifiers defines an operational area. This consists of the
    /// union of all constraints listed. The returned plan will not require the vehicle to leave the operational area.
    /// Avoid constraints take precedence over operational constraints if both are specified.
    public var operationalConstraintID: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Recommendation for a vehicle
public struct Rideos_Fleet_V2_VehiclePlanRecommendation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of the vehicle for whom this recommendation applies.
  public var vehicleID: String = String()

  /// The plan recommendation for the vehicle.
  public var planRecommendation: Rideos_Fleet_V2_VehiclePlan {
    get {return _planRecommendation ?? Rideos_Fleet_V2_VehiclePlan()}
    set {_planRecommendation = newValue}
  }
  /// Returns true if `planRecommendation` has been explicitly set.
  public var hasPlanRecommendation: Bool {return self._planRecommendation != nil}
  /// Clears the value of `planRecommendation`. Subsequent reads from it will return its default value.
  public mutating func clearPlanRecommendation() {self._planRecommendation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _planRecommendation: Rideos_Fleet_V2_VehiclePlan? = nil
}

/// Vehicle plan
public struct Rideos_Fleet_V2_VehiclePlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The steps to be completed, in order.
  public var assignedSteps: [Rideos_Fleet_V2_AssignedStep] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Assigned step
public struct Rideos_Fleet_V2_AssignedStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier of the corresponding Task.
  public var taskID: String = String()

  /// Whether this AssignedStep corresponds to the pickup or dropoff step.
  public var stepType: Rideos_Fleet_V2_AssignedStep.StepType = .unknown

  /// The remaining time to finish the step in seconds. This value is ignored for initial plans in the request because
  /// they get overwritten with updated values.
  /// For pickup and dropoff steps, this remaining time is just the cumulative time it takes to reach the step. For
  /// servicing dropoff steps, this remaining time is the sum of the cumulative time it takes to reach the step and the
  /// specified duration to complete the step.
  public var remainingTime: Double = 0

  /// Whether this AssignedStep corresponds to a pickup, dropoff, or servicing dropoff step
  public var assignedStepType: Rideos_Fleet_V2_AssignedStep.OneOf_AssignedStepType? = nil

  public var pickup: Rideos_Fleet_V2_AssignedStep.Pickup {
    get {
      if case .pickup(let v)? = assignedStepType {return v}
      return Rideos_Fleet_V2_AssignedStep.Pickup()
    }
    set {assignedStepType = .pickup(newValue)}
  }

  public var dropoff: Rideos_Fleet_V2_AssignedStep.Dropoff {
    get {
      if case .dropoff(let v)? = assignedStepType {return v}
      return Rideos_Fleet_V2_AssignedStep.Dropoff()
    }
    set {assignedStepType = .dropoff(newValue)}
  }

  public var servicingDropoff: Rideos_Fleet_V2_AssignedStep.ServicingDropoff {
    get {
      if case .servicingDropoff(let v)? = assignedStepType {return v}
      return Rideos_Fleet_V2_AssignedStep.ServicingDropoff()
    }
    set {assignedStepType = .servicingDropoff(newValue)}
  }

  public var servicingPickup: Rideos_Fleet_V2_AssignedStep.ServicingPickup {
    get {
      if case .servicingPickup(let v)? = assignedStepType {return v}
      return Rideos_Fleet_V2_AssignedStep.ServicingPickup()
    }
    set {assignedStepType = .servicingPickup(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Whether this AssignedStep corresponds to a pickup, dropoff, or servicing dropoff step
  public enum OneOf_AssignedStepType: Equatable {
    case pickup(Rideos_Fleet_V2_AssignedStep.Pickup)
    case dropoff(Rideos_Fleet_V2_AssignedStep.Dropoff)
    case servicingDropoff(Rideos_Fleet_V2_AssignedStep.ServicingDropoff)
    case servicingPickup(Rideos_Fleet_V2_AssignedStep.ServicingPickup)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Fleet_V2_AssignedStep.OneOf_AssignedStepType, rhs: Rideos_Fleet_V2_AssignedStep.OneOf_AssignedStepType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pickup, .pickup): return {
        guard case .pickup(let l) = lhs, case .pickup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dropoff, .dropoff): return {
        guard case .dropoff(let l) = lhs, case .dropoff(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.servicingDropoff, .servicingDropoff): return {
        guard case .servicingDropoff(let l) = lhs, case .servicingDropoff(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.servicingPickup, .servicingPickup): return {
        guard case .servicingPickup(let l) = lhs, case .servicingPickup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum StepType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case pickup // = 1
    case dropoff // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .pickup
      case 2: self = .dropoff
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .pickup: return 1
      case .dropoff: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Since a Task with a VariablePickupStep could have multiple options for the pickup, Fleet Planner will choose the most optimum and
  /// provide the selected location within this message.
  public struct Pickup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The selected position at which the Step should occur.
    public var position: Rideos_Geo_V1_Position {
      get {return _position ?? Rideos_Geo_V1_Position()}
      set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() {self._position = nil}

    /// Optional: The heading of the street at the Step position. Used to disambiguate side-of-street.
    /// Measured clockwise from true North - i.e. 0 is true North, 90 is East, 180 is South, 270 is West, etc..
    public var heading: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _heading ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_heading = newValue}
    }
    /// Returns true if `heading` has been explicitly set.
    public var hasHeading: Bool {return self._heading != nil}
    /// Clears the value of `heading`. Subsequent reads from it will return its default value.
    public mutating func clearHeading() {self._heading = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _position: Rideos_Geo_V1_Position? = nil
    fileprivate var _heading: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  }

  public struct Dropoff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ServicingDropoff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Remaining time between when the vehicle arrives at the dropoff location and when it is ready to leave the
    /// dropoff location. (ex: "60s" for 60 seconds)
    public var remainingDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _remainingDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_remainingDuration = newValue}
    }
    /// Returns true if `remainingDuration` has been explicitly set.
    public var hasRemainingDuration: Bool {return self._remainingDuration != nil}
    /// Clears the value of `remainingDuration`. Subsequent reads from it will return its default value.
    public mutating func clearRemainingDuration() {self._remainingDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _remainingDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public struct ServicingPickup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Remaining time between when the vehicle arrives at the pickup location and when it is ready to leave the
    /// pickup location. (ex: "60s" for 60 seconds)
    public var remainingDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _remainingDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_remainingDuration = newValue}
    }
    /// Returns true if `remainingDuration` has been explicitly set.
    public var hasRemainingDuration: Bool {return self._remainingDuration != nil}
    /// Clears the value of `remainingDuration`. Subsequent reads from it will return its default value.
    public mutating func clearRemainingDuration() {self._remainingDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _remainingDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Rideos_Fleet_V2_AssignedStep.StepType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_Fleet_V2_AssignedStep.StepType] = [
    .unknown,
    .pickup,
    .dropoff,
  ]
}

#endif  // swift(>=4.2)

/// Task
public struct Rideos_Fleet_V2_Task {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of resources (ex: seats for passengers) that are consumed when the pickup step is completed and
  /// released when the dropoff step is completed.
  public var resourcesRequired: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._resourcesRequired ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._resourcesRequired = newValue}
  }
  /// Returns true if `resourcesRequired` has been explicitly set.
  public var hasResourcesRequired: Bool {return _storage._resourcesRequired != nil}
  /// Clears the value of `resourcesRequired`. Subsequent reads from it will return its default value.
  public mutating func clearResourcesRequired() {_uniqueStorage()._resourcesRequired = nil}

  /// The resources (ex: passengers, goods, etc) that need to be moved as part of this task.
  public var requestedResource: [Rideos_FleetPlannerCommons_ResourceAndCount] {
    get {return _storage._requestedResource}
    set {_uniqueStorage()._requestedResource = newValue}
  }

  /// The pickup step. Will always occur before the dropoff step.
  public var pickupStep: Rideos_Fleet_V2_Task.PickupStep {
    get {return _storage._pickupStep ?? Rideos_Fleet_V2_Task.PickupStep()}
    set {_uniqueStorage()._pickupStep = newValue}
  }
  /// Returns true if `pickupStep` has been explicitly set.
  public var hasPickupStep: Bool {return _storage._pickupStep != nil}
  /// Clears the value of `pickupStep`. Subsequent reads from it will return its default value.
  public mutating func clearPickupStep() {_uniqueStorage()._pickupStep = nil}

  public var pickupStepType: OneOf_PickupStepType? {
    get {return _storage._pickupStepType}
    set {_uniqueStorage()._pickupStepType = newValue}
  }

  /// The pickup step with a specific pickup location. Will always occur before the dropoff step.
  public var staticPickupStep: Rideos_Fleet_V2_Task.PickupStep {
    get {
      if case .staticPickupStep(let v)? = _storage._pickupStepType {return v}
      return Rideos_Fleet_V2_Task.PickupStep()
    }
    set {_uniqueStorage()._pickupStepType = .staticPickupStep(newValue)}
  }

  /// The pickup step where the pickup location is not fixed. The pickup location will be dynamically selected from
  /// inventory within the vehicle itself.
  public var variablePickupStep: Rideos_Fleet_V2_Task.VariablePickupStep {
    get {
      if case .variablePickupStep(let v)? = _storage._pickupStepType {return v}
      return Rideos_Fleet_V2_Task.VariablePickupStep()
    }
    set {_uniqueStorage()._pickupStepType = .variablePickupStep(newValue)}
  }

  /// The dropoff step. Will always occur after the pickup step.
  public var dropoffStep: Rideos_Fleet_V2_Task.DropoffStep {
    get {return _storage._dropoffStep ?? Rideos_Fleet_V2_Task.DropoffStep()}
    set {_uniqueStorage()._dropoffStep = newValue}
  }
  /// Returns true if `dropoffStep` has been explicitly set.
  public var hasDropoffStep: Bool {return _storage._dropoffStep != nil}
  /// Clears the value of `dropoffStep`. Subsequent reads from it will return its default value.
  public mutating func clearDropoffStep() {_uniqueStorage()._dropoffStep = nil}

  /// Whether or not the task should be served as a shared or private ride. If this is set to true, the task will be
  /// served by a vehicle and not pooled with other tasks.
  public var privateRide: Bool {
    get {return _storage._privateRide}
    set {_uniqueStorage()._privateRide = newValue}
  }

  public var blacklistedVehicleID: [String] {
    get {return _storage._blacklistedVehicleID}
    set {_uniqueStorage()._blacklistedVehicleID = newValue}
  }

  public var whitelistedVehicleID: [String] {
    get {return _storage._whitelistedVehicleID}
    set {_uniqueStorage()._whitelistedVehicleID = newValue}
  }

  /// Fleet planner will be constrained to never assign this task to excluded vehicles. Excluded vehicles will
  /// override allowed vehicles.
  /// These are ignored if the pickup has already been completed by any vehicle, denoted by the completedByVehicleId
  /// field in the Task's pickup step.
  public var excludedVehicleID: [String] {
    get {return _storage._excludedVehicleID}
    set {_uniqueStorage()._excludedVehicleID = newValue}
  }

  /// Fleet planner will be constrained to only assign this task to allowed vehicles. Allowed vehicles will
  /// be overriden by excluded vehicles.
  /// These are ignored if the pickup has already been completed by any vehicle, denoted by the completedByVehicleId
  /// field in the Task's pickup step.
  public var allowedVehicleID: [String] {
    get {return _storage._allowedVehicleID}
    set {_uniqueStorage()._allowedVehicleID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PickupStepType: Equatable {
    /// The pickup step with a specific pickup location. Will always occur before the dropoff step.
    case staticPickupStep(Rideos_Fleet_V2_Task.PickupStep)
    /// The pickup step where the pickup location is not fixed. The pickup location will be dynamically selected from
    /// inventory within the vehicle itself.
    case variablePickupStep(Rideos_Fleet_V2_Task.VariablePickupStep)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Fleet_V2_Task.OneOf_PickupStepType, rhs: Rideos_Fleet_V2_Task.OneOf_PickupStepType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.staticPickupStep, .staticPickupStep): return {
        guard case .staticPickupStep(let l) = lhs, case .staticPickupStep(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.variablePickupStep, .variablePickupStep): return {
        guard case .variablePickupStep(let l) = lhs, case .variablePickupStep(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A step used to mandate a pickup position from where a pickup must happen. It also contains other pickup related
  /// properties. Used for point-to-point transportation of unique resources. For example, passenger rides, meal
  /// delivery, package delivery, etc.
  public struct PickupStep {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The desired position at which the Step should occur.
    public var position: Rideos_Geo_V1_Position {
      get {return _position ?? Rideos_Geo_V1_Position()}
      set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() {self._position = nil}

    /// Optional: The heading of the street at the Step position. Used to disambiguate side-of-street.
    /// Measured clockwise from true North - i.e. 0 is true North, 90 is East, 180 is South, 270 is West, etc..
    public var heading: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _heading ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_heading = newValue}
    }
    /// Returns true if `heading` has been explicitly set.
    public var hasHeading: Bool {return self._heading != nil}
    /// Clears the value of `heading`. Subsequent reads from it will return its default value.
    public mutating func clearHeading() {self._heading = nil}

    /// If the PickupStep has been completed, this should equal the ID of the vehicle that completed the step.
    /// If the PickupStep has not been completed, this should be omitted/empty.
    public var completedByVehicleID: String = String()

    /// Desired time window within which this step should occur.
    public var desiredServiceTime: Rideos_Fleet_V2_TimeWindow {
      get {return _desiredServiceTime ?? Rideos_Fleet_V2_TimeWindow()}
      set {_desiredServiceTime = newValue}
    }
    /// Returns true if `desiredServiceTime` has been explicitly set.
    public var hasDesiredServiceTime: Bool {return self._desiredServiceTime != nil}
    /// Clears the value of `desiredServiceTime`. Subsequent reads from it will return its default value.
    public mutating func clearDesiredServiceTime() {self._desiredServiceTime = nil}

    /// If the pickup has not been completed yet, we will assign this task to the desired vehicle id. This is ignored
    /// if the pickup has been completed.
    public var desiredVehicleID: String = String()

    /// Expected time between when the vehicle arrives at the pickup location and when it is ready to leave the
    /// pickup location. ex: if picking up a rider, this would include the expected duration for the rider to enter
    /// the vehicle.
    public var expectedServicingPickupDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _expectedServicingPickupDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_expectedServicingPickupDuration = newValue}
    }
    /// Returns true if `expectedServicingPickupDuration` has been explicitly set.
    public var hasExpectedServicingPickupDuration: Bool {return self._expectedServicingPickupDuration != nil}
    /// Clears the value of `expectedServicingPickupDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExpectedServicingPickupDuration() {self._expectedServicingPickupDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _position: Rideos_Geo_V1_Position? = nil
    fileprivate var _heading: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    fileprivate var _desiredServiceTime: Rideos_Fleet_V2_TimeWindow? = nil
    fileprivate var _expectedServicingPickupDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  /// A step used to suggest a pickup from vehicles with inventory provided in the request. If the inventory of
  /// the vehicle can satisfy the task then the pickup step will be skipped. Used for warehouse on
  /// wheels style delivery of generic resources. For example, grocery delivery, meat delivery, etc.
  public struct VariablePickupStep {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Desired time window within which this step should occur.
    public var desiredServiceTime: Rideos_Fleet_V2_TimeWindow {
      get {return _desiredServiceTime ?? Rideos_Fleet_V2_TimeWindow()}
      set {_desiredServiceTime = newValue}
    }
    /// Returns true if `desiredServiceTime` has been explicitly set.
    public var hasDesiredServiceTime: Bool {return self._desiredServiceTime != nil}
    /// Clears the value of `desiredServiceTime`. Subsequent reads from it will return its default value.
    public mutating func clearDesiredServiceTime() {self._desiredServiceTime = nil}

    /// Expected time between when the vehicle arrives at the pickup location and when it is ready to leave the
    /// pickup location. ex: if picking up a rider, this would include the expected duration for the rider to enter
    /// the vehicle.
    public var expectedServicingPickupDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _expectedServicingPickupDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_expectedServicingPickupDuration = newValue}
    }
    /// Returns true if `expectedServicingPickupDuration` has been explicitly set.
    public var hasExpectedServicingPickupDuration: Bool {return self._expectedServicingPickupDuration != nil}
    /// Clears the value of `expectedServicingPickupDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExpectedServicingPickupDuration() {self._expectedServicingPickupDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _desiredServiceTime: Rideos_Fleet_V2_TimeWindow? = nil
    fileprivate var _expectedServicingPickupDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public struct DropoffStep {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The desired position at which the Step should occur.
    public var position: Rideos_Geo_V1_Position {
      get {return _position ?? Rideos_Geo_V1_Position()}
      set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() {self._position = nil}

    /// Optional: The heading of the street at the Step position. Used to disambiguate side-of-street.
    /// Measured clockwise from true North - i.e. 0 is true North, 90 is East, 180 is South, 270 is West, etc..
    public var heading: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _heading ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_heading = newValue}
    }
    /// Returns true if `heading` has been explicitly set.
    public var hasHeading: Bool {return self._heading != nil}
    /// Clears the value of `heading`. Subsequent reads from it will return its default value.
    public mutating func clearHeading() {self._heading = nil}

    /// Desired time window within which this step should occur.
    public var desiredServiceTime: Rideos_Fleet_V2_TimeWindow {
      get {return _desiredServiceTime ?? Rideos_Fleet_V2_TimeWindow()}
      set {_desiredServiceTime = newValue}
    }
    /// Returns true if `desiredServiceTime` has been explicitly set.
    public var hasDesiredServiceTime: Bool {return self._desiredServiceTime != nil}
    /// Clears the value of `desiredServiceTime`. Subsequent reads from it will return its default value.
    public mutating func clearDesiredServiceTime() {self._desiredServiceTime = nil}

    /// Expected time between when the vehicle arrives at the dropoff location and when it is ready to leave the
    /// dropoff location. ex: if dropping off a rider, this would include the expected duration for the rider to exit
    /// the vehicle.
    public var expectedServicingDropoffDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _expectedServicingDropoffDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_expectedServicingDropoffDuration = newValue}
    }
    /// Returns true if `expectedServicingDropoffDuration` has been explicitly set.
    public var hasExpectedServicingDropoffDuration: Bool {return self._expectedServicingDropoffDuration != nil}
    /// Clears the value of `expectedServicingDropoffDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExpectedServicingDropoffDuration() {self._expectedServicingDropoffDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _position: Rideos_Geo_V1_Position? = nil
    fileprivate var _heading: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    fileprivate var _desiredServiceTime: Rideos_Fleet_V2_TimeWindow? = nil
    fileprivate var _expectedServicingDropoffDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Time window
public struct Rideos_Fleet_V2_TimeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The beginning of the time window. If missing, this will default to negative infinity.
  public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  /// The end of the time window. If missing, this will default to positive infinity.
  public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rideos.fleet.v2"

extension Rideos_Fleet_V2_GetPlanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPlanRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicles"),
    4: .same(proto: "tasks"),
    5: .standard(proto: "allow_vehicle_reassignment"),
    6: .standard(proto: "optimize_for"),
    7: .standard(proto: "eta_prediction_type"),
    8: .standard(proto: "include_servicing_dropoff_step_in_plan"),
    9: .standard(proto: "vehicle_reassignment_configuration"),
    10: .standard(proto: "include_servicing_pickup_step_in_plan"),
    13: .same(proto: "resource"),
    15: .standard(proto: "allow_out_of_bounds_assignments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Rideos_Fleet_V2_Vehicle>.self, value: &self.vehicles) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Rideos_Fleet_V2_Task>.self, value: &self.tasks) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowVehicleReassignment) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.optimizeFor) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.etaPredictionType) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.includeServicingDropoffStepInPlan) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._vehicleReassignmentConfiguration) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.includeServicingPickupStepInPlan) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.resource) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.allowOutOfBoundsAssignments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicles.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Rideos_Fleet_V2_Vehicle>.self, value: self.vehicles, fieldNumber: 1)
    }
    if !self.tasks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Rideos_Fleet_V2_Task>.self, value: self.tasks, fieldNumber: 4)
    }
    if self.allowVehicleReassignment != false {
      try visitor.visitSingularBoolField(value: self.allowVehicleReassignment, fieldNumber: 5)
    }
    if self.optimizeFor != .default {
      try visitor.visitSingularEnumField(value: self.optimizeFor, fieldNumber: 6)
    }
    if self.etaPredictionType != .realTimeTraffic {
      try visitor.visitSingularEnumField(value: self.etaPredictionType, fieldNumber: 7)
    }
    if self.includeServicingDropoffStepInPlan != false {
      try visitor.visitSingularBoolField(value: self.includeServicingDropoffStepInPlan, fieldNumber: 8)
    }
    if let v = self._vehicleReassignmentConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if self.includeServicingPickupStepInPlan != false {
      try visitor.visitSingularBoolField(value: self.includeServicingPickupStepInPlan, fieldNumber: 10)
    }
    if !self.resource.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resource, fieldNumber: 13)
    }
    if self.allowOutOfBoundsAssignments != false {
      try visitor.visitSingularBoolField(value: self.allowOutOfBoundsAssignments, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_GetPlanRequest, rhs: Rideos_Fleet_V2_GetPlanRequest) -> Bool {
    if lhs.vehicles != rhs.vehicles {return false}
    if lhs.tasks != rhs.tasks {return false}
    if lhs.allowVehicleReassignment != rhs.allowVehicleReassignment {return false}
    if lhs.optimizeFor != rhs.optimizeFor {return false}
    if lhs.etaPredictionType != rhs.etaPredictionType {return false}
    if lhs.includeServicingDropoffStepInPlan != rhs.includeServicingDropoffStepInPlan {return false}
    if lhs._vehicleReassignmentConfiguration != rhs._vehicleReassignmentConfiguration {return false}
    if lhs.includeServicingPickupStepInPlan != rhs.includeServicingPickupStepInPlan {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.allowOutOfBoundsAssignments != rhs.allowOutOfBoundsAssignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_GetPlanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPlanResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recommendations"),
    2: .standard(proto: "unresolved_tasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.recommendations) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unresolvedTasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recommendations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recommendations, fieldNumber: 1)
    }
    if !self.unresolvedTasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unresolvedTasks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_GetPlanResponse, rhs: Rideos_Fleet_V2_GetPlanResponse) -> Bool {
    if lhs.recommendations != rhs.recommendations {return false}
    if lhs.unresolvedTasks != rhs.unresolvedTasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_UnresolvedTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnresolvedTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "unresolvable_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unresolvableReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if !self.unresolvableReason.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unresolvableReason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_UnresolvedTask, rhs: Rideos_Fleet_V2_UnresolvedTask) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unresolvableReason != rhs.unresolvableReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_Vehicle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vehicle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "heading"),
    3: .standard(proto: "resource_capacity"),
    9: .same(proto: "capacity"),
    10: .same(proto: "inventory"),
    4: .standard(proto: "current_plan"),
    5: .standard(proto: "vehicle_id"),
    6: .standard(proto: "restrict_task_insertions_up_to"),
    7: .standard(proto: "routing_constraints"),
    8: .standard(proto: "shift_time_window"),
    11: .standard(proto: "routing_profile_id"),
  ]

  fileprivate class _StorageClass {
    var _position: Rideos_Geo_V1_Position? = nil
    var _heading: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    var _resourceCapacity: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _capacity: [Rideos_FleetPlannerCommons_CapacityLimit] = []
    var _inventory: [Rideos_FleetPlannerCommons_ResourceAndCount] = []
    var _currentPlan: Rideos_Fleet_V2_VehiclePlan? = nil
    var _vehicleID: String = String()
    var _restrictTaskInsertionsUpTo: UInt32 = 0
    var _routingConstraints: Rideos_Fleet_V2_Vehicle.RoutingConstraints? = nil
    var _shiftTimeWindow: Rideos_Fleet_V2_TimeWindow? = nil
    var _routingProfileID: SwiftProtobuf.Google_Protobuf_StringValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _position = source._position
      _heading = source._heading
      _resourceCapacity = source._resourceCapacity
      _capacity = source._capacity
      _inventory = source._inventory
      _currentPlan = source._currentPlan
      _vehicleID = source._vehicleID
      _restrictTaskInsertionsUpTo = source._restrictTaskInsertionsUpTo
      _routingConstraints = source._routingConstraints
      _shiftTimeWindow = source._shiftTimeWindow
      _routingProfileID = source._routingProfileID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._heading) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resourceCapacity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._currentPlan) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._vehicleID) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._restrictTaskInsertionsUpTo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._routingConstraints) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._shiftTimeWindow) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._capacity) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._inventory) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._routingProfileID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._heading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._resourceCapacity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._currentPlan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._vehicleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vehicleID, fieldNumber: 5)
      }
      if _storage._restrictTaskInsertionsUpTo != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._restrictTaskInsertionsUpTo, fieldNumber: 6)
      }
      if let v = _storage._routingConstraints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._shiftTimeWindow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._capacity.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._capacity, fieldNumber: 9)
      }
      if !_storage._inventory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inventory, fieldNumber: 10)
      }
      if let v = _storage._routingProfileID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_Vehicle, rhs: Rideos_Fleet_V2_Vehicle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._position != rhs_storage._position {return false}
        if _storage._heading != rhs_storage._heading {return false}
        if _storage._resourceCapacity != rhs_storage._resourceCapacity {return false}
        if _storage._capacity != rhs_storage._capacity {return false}
        if _storage._inventory != rhs_storage._inventory {return false}
        if _storage._currentPlan != rhs_storage._currentPlan {return false}
        if _storage._vehicleID != rhs_storage._vehicleID {return false}
        if _storage._restrictTaskInsertionsUpTo != rhs_storage._restrictTaskInsertionsUpTo {return false}
        if _storage._routingConstraints != rhs_storage._routingConstraints {return false}
        if _storage._shiftTimeWindow != rhs_storage._shiftTimeWindow {return false}
        if _storage._routingProfileID != rhs_storage._routingProfileID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_Vehicle.RoutingConstraints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_Vehicle.protoMessageName + ".RoutingConstraints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blacklist_constraint_id"),
    2: .standard(proto: "whitelist_constraint_id"),
    3: .standard(proto: "avoid_constraint_id"),
    4: .standard(proto: "operational_constraint_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.blacklistConstraintID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.whitelistConstraintID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.avoidConstraintID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.operationalConstraintID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blacklistConstraintID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blacklistConstraintID, fieldNumber: 1)
    }
    if !self.whitelistConstraintID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.whitelistConstraintID, fieldNumber: 2)
    }
    if !self.avoidConstraintID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.avoidConstraintID, fieldNumber: 3)
    }
    if !self.operationalConstraintID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.operationalConstraintID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_Vehicle.RoutingConstraints, rhs: Rideos_Fleet_V2_Vehicle.RoutingConstraints) -> Bool {
    if lhs.blacklistConstraintID != rhs.blacklistConstraintID {return false}
    if lhs.whitelistConstraintID != rhs.whitelistConstraintID {return false}
    if lhs.avoidConstraintID != rhs.avoidConstraintID {return false}
    if lhs.operationalConstraintID != rhs.operationalConstraintID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_VehiclePlanRecommendation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehiclePlanRecommendation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_id"),
    2: .standard(proto: "plan_recommendation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vehicleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._planRecommendation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.vehicleID, fieldNumber: 1)
    }
    if let v = self._planRecommendation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_VehiclePlanRecommendation, rhs: Rideos_Fleet_V2_VehiclePlanRecommendation) -> Bool {
    if lhs.vehicleID != rhs.vehicleID {return false}
    if lhs._planRecommendation != rhs._planRecommendation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_VehiclePlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehiclePlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "assigned_steps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assignedSteps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignedSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignedSteps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_VehiclePlan, rhs: Rideos_Fleet_V2_VehiclePlan) -> Bool {
    if lhs.assignedSteps != rhs.assignedSteps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_AssignedStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssignedStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "step_type"),
    3: .standard(proto: "remaining_time"),
    4: .same(proto: "pickup"),
    5: .same(proto: "dropoff"),
    6: .standard(proto: "servicing_dropoff"),
    7: .standard(proto: "servicing_pickup"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.stepType) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.remainingTime) }()
      case 4: try {
        var v: Rideos_Fleet_V2_AssignedStep.Pickup?
        if let current = self.assignedStepType {
          try decoder.handleConflictingOneOf()
          if case .pickup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.assignedStepType = .pickup(v)}
      }()
      case 5: try {
        var v: Rideos_Fleet_V2_AssignedStep.Dropoff?
        if let current = self.assignedStepType {
          try decoder.handleConflictingOneOf()
          if case .dropoff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.assignedStepType = .dropoff(v)}
      }()
      case 6: try {
        var v: Rideos_Fleet_V2_AssignedStep.ServicingDropoff?
        if let current = self.assignedStepType {
          try decoder.handleConflictingOneOf()
          if case .servicingDropoff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.assignedStepType = .servicingDropoff(v)}
      }()
      case 7: try {
        var v: Rideos_Fleet_V2_AssignedStep.ServicingPickup?
        if let current = self.assignedStepType {
          try decoder.handleConflictingOneOf()
          if case .servicingPickup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.assignedStepType = .servicingPickup(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.stepType != .unknown {
      try visitor.visitSingularEnumField(value: self.stepType, fieldNumber: 2)
    }
    if self.remainingTime != 0 {
      try visitor.visitSingularDoubleField(value: self.remainingTime, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.assignedStepType {
    case .pickup?: try {
      guard case .pickup(let v)? = self.assignedStepType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dropoff?: try {
      guard case .dropoff(let v)? = self.assignedStepType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .servicingDropoff?: try {
      guard case .servicingDropoff(let v)? = self.assignedStepType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .servicingPickup?: try {
      guard case .servicingPickup(let v)? = self.assignedStepType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_AssignedStep, rhs: Rideos_Fleet_V2_AssignedStep) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.stepType != rhs.stepType {return false}
    if lhs.remainingTime != rhs.remainingTime {return false}
    if lhs.assignedStepType != rhs.assignedStepType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_AssignedStep.StepType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PICKUP"),
    2: .same(proto: "DROPOFF"),
  ]
}

extension Rideos_Fleet_V2_AssignedStep.Pickup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_AssignedStep.protoMessageName + ".Pickup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "heading"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heading) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._heading {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_AssignedStep.Pickup, rhs: Rideos_Fleet_V2_AssignedStep.Pickup) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._heading != rhs._heading {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_AssignedStep.Dropoff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_AssignedStep.protoMessageName + ".Dropoff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_AssignedStep.Dropoff, rhs: Rideos_Fleet_V2_AssignedStep.Dropoff) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_AssignedStep.ServicingDropoff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_AssignedStep.protoMessageName + ".ServicingDropoff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remaining_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._remainingDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._remainingDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_AssignedStep.ServicingDropoff, rhs: Rideos_Fleet_V2_AssignedStep.ServicingDropoff) -> Bool {
    if lhs._remainingDuration != rhs._remainingDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_AssignedStep.ServicingPickup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_AssignedStep.protoMessageName + ".ServicingPickup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remaining_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._remainingDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._remainingDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_AssignedStep.ServicingPickup, rhs: Rideos_Fleet_V2_AssignedStep.ServicingPickup) -> Bool {
    if lhs._remainingDuration != rhs._remainingDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_Task: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Task"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resources_required"),
    7: .standard(proto: "requested_resource"),
    2: .standard(proto: "pickup_step"),
    8: .standard(proto: "static_pickup_step"),
    9: .standard(proto: "variable_pickup_step"),
    3: .standard(proto: "dropoff_step"),
    4: .standard(proto: "private_ride"),
    5: .standard(proto: "blacklisted_vehicle_id"),
    6: .standard(proto: "whitelisted_vehicle_id"),
    10: .standard(proto: "excluded_vehicle_id"),
    11: .standard(proto: "allowed_vehicle_id"),
  ]

  fileprivate class _StorageClass {
    var _resourcesRequired: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _requestedResource: [Rideos_FleetPlannerCommons_ResourceAndCount] = []
    var _pickupStep: Rideos_Fleet_V2_Task.PickupStep? = nil
    var _pickupStepType: Rideos_Fleet_V2_Task.OneOf_PickupStepType?
    var _dropoffStep: Rideos_Fleet_V2_Task.DropoffStep? = nil
    var _privateRide: Bool = false
    var _blacklistedVehicleID: [String] = []
    var _whitelistedVehicleID: [String] = []
    var _excludedVehicleID: [String] = []
    var _allowedVehicleID: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _resourcesRequired = source._resourcesRequired
      _requestedResource = source._requestedResource
      _pickupStep = source._pickupStep
      _pickupStepType = source._pickupStepType
      _dropoffStep = source._dropoffStep
      _privateRide = source._privateRide
      _blacklistedVehicleID = source._blacklistedVehicleID
      _whitelistedVehicleID = source._whitelistedVehicleID
      _excludedVehicleID = source._excludedVehicleID
      _allowedVehicleID = source._allowedVehicleID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._resourcesRequired) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pickupStep) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dropoffStep) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._privateRide) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._blacklistedVehicleID) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._whitelistedVehicleID) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestedResource) }()
        case 8: try {
          var v: Rideos_Fleet_V2_Task.PickupStep?
          if let current = _storage._pickupStepType {
            try decoder.handleConflictingOneOf()
            if case .staticPickupStep(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._pickupStepType = .staticPickupStep(v)}
        }()
        case 9: try {
          var v: Rideos_Fleet_V2_Task.VariablePickupStep?
          if let current = _storage._pickupStepType {
            try decoder.handleConflictingOneOf()
            if case .variablePickupStep(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._pickupStepType = .variablePickupStep(v)}
        }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._excludedVehicleID) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._allowedVehicleID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._resourcesRequired {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pickupStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._dropoffStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._privateRide != false {
        try visitor.visitSingularBoolField(value: _storage._privateRide, fieldNumber: 4)
      }
      if !_storage._blacklistedVehicleID.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._blacklistedVehicleID, fieldNumber: 5)
      }
      if !_storage._whitelistedVehicleID.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._whitelistedVehicleID, fieldNumber: 6)
      }
      if !_storage._requestedResource.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestedResource, fieldNumber: 7)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._pickupStepType {
      case .staticPickupStep?: try {
        guard case .staticPickupStep(let v)? = _storage._pickupStepType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .variablePickupStep?: try {
        guard case .variablePickupStep(let v)? = _storage._pickupStepType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      if !_storage._excludedVehicleID.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._excludedVehicleID, fieldNumber: 10)
      }
      if !_storage._allowedVehicleID.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedVehicleID, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_Task, rhs: Rideos_Fleet_V2_Task) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._resourcesRequired != rhs_storage._resourcesRequired {return false}
        if _storage._requestedResource != rhs_storage._requestedResource {return false}
        if _storage._pickupStep != rhs_storage._pickupStep {return false}
        if _storage._pickupStepType != rhs_storage._pickupStepType {return false}
        if _storage._dropoffStep != rhs_storage._dropoffStep {return false}
        if _storage._privateRide != rhs_storage._privateRide {return false}
        if _storage._blacklistedVehicleID != rhs_storage._blacklistedVehicleID {return false}
        if _storage._whitelistedVehicleID != rhs_storage._whitelistedVehicleID {return false}
        if _storage._excludedVehicleID != rhs_storage._excludedVehicleID {return false}
        if _storage._allowedVehicleID != rhs_storage._allowedVehicleID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_Task.PickupStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_Task.protoMessageName + ".PickupStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "heading"),
    3: .standard(proto: "completed_by_vehicle_id"),
    4: .standard(proto: "desired_service_time"),
    6: .standard(proto: "desired_vehicle_id"),
    7: .standard(proto: "expected_servicing_pickup_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heading) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.completedByVehicleID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._desiredServiceTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.desiredVehicleID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._expectedServicingPickupDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._heading {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.completedByVehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.completedByVehicleID, fieldNumber: 3)
    }
    if let v = self._desiredServiceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.desiredVehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.desiredVehicleID, fieldNumber: 6)
    }
    if let v = self._expectedServicingPickupDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_Task.PickupStep, rhs: Rideos_Fleet_V2_Task.PickupStep) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._heading != rhs._heading {return false}
    if lhs.completedByVehicleID != rhs.completedByVehicleID {return false}
    if lhs._desiredServiceTime != rhs._desiredServiceTime {return false}
    if lhs.desiredVehicleID != rhs.desiredVehicleID {return false}
    if lhs._expectedServicingPickupDuration != rhs._expectedServicingPickupDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_Task.VariablePickupStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_Task.protoMessageName + ".VariablePickupStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "desired_service_time"),
    2: .standard(proto: "expected_servicing_pickup_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._desiredServiceTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expectedServicingPickupDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._desiredServiceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._expectedServicingPickupDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_Task.VariablePickupStep, rhs: Rideos_Fleet_V2_Task.VariablePickupStep) -> Bool {
    if lhs._desiredServiceTime != rhs._desiredServiceTime {return false}
    if lhs._expectedServicingPickupDuration != rhs._expectedServicingPickupDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_Task.DropoffStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_Fleet_V2_Task.protoMessageName + ".DropoffStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "heading"),
    3: .standard(proto: "desired_service_time"),
    4: .standard(proto: "expected_servicing_dropoff_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heading) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._desiredServiceTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expectedServicingDropoffDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._heading {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._desiredServiceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._expectedServicingDropoffDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_Task.DropoffStep, rhs: Rideos_Fleet_V2_Task.DropoffStep) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._heading != rhs._heading {return false}
    if lhs._desiredServiceTime != rhs._desiredServiceTime {return false}
    if lhs._expectedServicingDropoffDuration != rhs._expectedServicingDropoffDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Fleet_V2_TimeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Fleet_V2_TimeWindow, rhs: Rideos_Fleet_V2_TimeWindow) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
