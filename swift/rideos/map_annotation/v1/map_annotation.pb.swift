// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rideos/map_annotation/v1/map_annotation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2018-2019 rideOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rideos_MapAnnotation_V1_AnnotationStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Annotation status is unknown, error when fetching the status
  case unknown // = 0

  /// Annotation has been processed and is used by routing
  case active // = 1

  /// Annotation has been added but no processed yet
  case inactive // = 2

  /// Annotation with given identifier does not exist
  case invalid // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .active
    case 2: self = .inactive
    case 3: self = .invalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .active: return 1
    case .inactive: return 2
    case .invalid: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rideos_MapAnnotation_V1_AnnotationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_MapAnnotation_V1_AnnotationStatus] = [
    .unknown,
    .active,
    .inactive,
    .invalid,
  ]
}

#endif  // swift(>=4.2)

/// Feature
public struct Rideos_MapAnnotation_V1_Feature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Rideos_MapAnnotation_V1_Feature.OneOf_Type? = nil

  /// An area marks all intersecting streets to be included into the annotation.
  public var area: Rideos_Geo_V1_Shape {
    get {
      if case .area(let v)? = type {return v}
      return Rideos_Geo_V1_Shape()
    }
    set {type = .area(newValue)}
  }

  /// A path allows to annotate all streets which best match a given polyline. Note that streets which are partially matched will still be included into the annotation.
  public var path: Rideos_Geo_V1_LineString {
    get {
      if case .path(let v)? = type {return v}
      return Rideos_Geo_V1_LineString()
    }
    set {type = .path(newValue)}
  }

  /// Allows to annotate the turn which best matches a given polyline.
  public var turn: Rideos_Geo_V1_LineString {
    get {
      if case .turn(let v)? = type {return v}
      return Rideos_Geo_V1_LineString()
    }
    set {type = .turn(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// An area marks all intersecting streets to be included into the annotation.
    case area(Rideos_Geo_V1_Shape)
    /// A path allows to annotate all streets which best match a given polyline. Note that streets which are partially matched will still be included into the annotation.
    case path(Rideos_Geo_V1_LineString)
    /// Allows to annotate the turn which best matches a given polyline.
    case turn(Rideos_Geo_V1_LineString)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_MapAnnotation_V1_Feature.OneOf_Type, rhs: Rideos_MapAnnotation_V1_Feature.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.area, .area): return {
        guard case .area(let l) = lhs, case .area(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.path, .path): return {
        guard case .path(let l) = lhs, case .path(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.turn, .turn): return {
        guard case .turn(let l) = lhs, case .turn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Rideos_MapAnnotation_V1_Criterion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attribute: Rideos_MapAnnotation_V1_Criterion.Attribute = .speedLimit

  public var function: Rideos_MapAnnotation_V1_Criterion.Function = .present

  public var value: Rideos_MapAnnotation_V1_Criterion.OneOf_Value? = nil

  public var numberValue: Double {
    get {
      if case .numberValue(let v)? = value {return v}
      return 0
    }
    set {value = .numberValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case numberValue(Double)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_MapAnnotation_V1_Criterion.OneOf_Value, rhs: Rideos_MapAnnotation_V1_Criterion.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.numberValue, .numberValue): return {
        guard case .numberValue(let l) = lhs, case .numberValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Attribute: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case speedLimit // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .speedLimit
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .speedLimit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .speedLimit: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Function: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case present // = 0
    case greaterThan // = 1
    case greaterThanEquals // = 2
    case lessThan // = 3
    case lessThanEquals // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .present
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .present
      case 1: self = .greaterThan
      case 2: self = .greaterThanEquals
      case 3: self = .lessThan
      case 4: self = .lessThanEquals
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .present: return 0
      case .greaterThan: return 1
      case .greaterThanEquals: return 2
      case .lessThan: return 3
      case .lessThanEquals: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Rideos_MapAnnotation_V1_Criterion.Attribute: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_MapAnnotation_V1_Criterion.Attribute] = [
    .speedLimit,
  ]
}

extension Rideos_MapAnnotation_V1_Criterion.Function: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_MapAnnotation_V1_Criterion.Function] = [
    .present,
    .greaterThan,
    .greaterThanEquals,
    .lessThan,
    .lessThanEquals,
  ]
}

#endif  // swift(>=4.2)

public struct Rideos_MapAnnotation_V1_Annotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partner-provided unique annotations identifier(max 100 characters).
  public var id: String = String()

  /// List of geometrical features. A feature can either be an `area`, `path` or `turn`, which can be achieved by setting the corresponding property.
  /// An area marks all intersecting streets to be included into the annotation.
  /// A path allows to annotate all streets which best match a given polyline. Note that streets which are partially matched will still be included into the annotation.
  /// Allows to annotate the turn which best matches a given polyline.
  public var features: [Rideos_MapAnnotation_V1_Feature] = []

  /// Additional properties for storing partner-specific information about the annotation.
  public var properties: Dictionary<String,String> = [:]

  /// List of criteria. Criteria allows for further filtering features by their properties.
  /// For example, only selecting roads with an area that have a speed limit above a certain value
  public var criteria: [Rideos_MapAnnotation_V1_Criterion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Annotation to add.
  public var annotation: Rideos_MapAnnotation_V1_Annotation {
    get {return _annotation ?? Rideos_MapAnnotation_V1_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Rideos_MapAnnotation_V1_Annotation? = nil
}

public struct Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_GetAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partner-provided annotation identifier.
  public var annotationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_GetAnnotationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var annotation: Rideos_MapAnnotation_V1_Annotation {
    get {return _annotation ?? Rideos_MapAnnotation_V1_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Rideos_MapAnnotation_V1_Annotation? = nil
}

public struct Rideos_MapAnnotation_V1_GetAllAnnotationIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_GetAllAnnotationIdsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifiers of all annotations for this partner.
  public var annotationIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_DeleteAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partner-provided annotation identifier.
  public var annotationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_DeleteAnnotationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_MatchAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Annotation to match.
  public var annotation: Rideos_MapAnnotation_V1_Annotation {
    get {return _annotation ?? Rideos_MapAnnotation_V1_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Rideos_MapAnnotation_V1_Annotation? = nil
}

public struct Rideos_MapAnnotation_V1_MatchAnnotationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Geometries of all edges this annotation matches to.
  public var edgesGeometry: [Rideos_Geo_V1_LineString] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var area: Rideos_Geo_V1_Shape {
    get {return _area ?? Rideos_Geo_V1_Shape()}
    set {_area = newValue}
  }
  /// Returns true if `area` has been explicitly set.
  public var hasArea: Bool {return self._area != nil}
  /// Clears the value of `area`. Subsequent reads from it will return its default value.
  public mutating func clearArea() {self._area = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _area: Rideos_Geo_V1_Shape? = nil
}

public struct Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var annotations: [Rideos_MapAnnotation_V1_Annotation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_GetAnnotationStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partner-provided annotation identifier.
  public var annotationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_MapAnnotation_V1_GetAnnotationStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Annotation status
  public var status: Rideos_MapAnnotation_V1_AnnotationStatus = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rideos.map_annotation.v1"

extension Rideos_MapAnnotation_V1_AnnotationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "INACTIVE"),
    3: .same(proto: "INVALID"),
  ]
}

extension Rideos_MapAnnotation_V1_Feature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Feature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "area"),
    2: .same(proto: "path"),
    3: .same(proto: "turn"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rideos_Geo_V1_Shape?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .area(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .area(v)}
      }()
      case 2: try {
        var v: Rideos_Geo_V1_LineString?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .path(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .path(v)}
      }()
      case 3: try {
        var v: Rideos_Geo_V1_LineString?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .turn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .turn(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .area?: try {
      guard case .area(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .path?: try {
      guard case .path(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .turn?: try {
      guard case .turn(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_Feature, rhs: Rideos_MapAnnotation_V1_Feature) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_Criterion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Criterion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attribute"),
    2: .same(proto: "function"),
    3: .standard(proto: "number_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.attribute) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.function) }()
      case 3: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.value = .numberValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attribute != .speedLimit {
      try visitor.visitSingularEnumField(value: self.attribute, fieldNumber: 1)
    }
    if self.function != .present {
      try visitor.visitSingularEnumField(value: self.function, fieldNumber: 2)
    }
    if case .numberValue(let v)? = self.value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_Criterion, rhs: Rideos_MapAnnotation_V1_Criterion) -> Bool {
    if lhs.attribute != rhs.attribute {return false}
    if lhs.function != rhs.function {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_Criterion.Attribute: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPEED_LIMIT"),
  ]
}

extension Rideos_MapAnnotation_V1_Criterion.Function: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESENT"),
    1: .same(proto: "GREATER_THAN"),
    2: .same(proto: "GREATER_THAN_EQUALS"),
    3: .same(proto: "LESS_THAN"),
    4: .same(proto: "LESS_THAN_EQUALS"),
  ]
}

extension Rideos_MapAnnotation_V1_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Annotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "features"),
    3: .same(proto: "properties"),
    4: .same(proto: "criteria"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.properties) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.criteria) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.properties, fieldNumber: 3)
    }
    if !self.criteria.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.criteria, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_Annotation, rhs: Rideos_MapAnnotation_V1_Annotation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.features != rhs.features {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.criteria != rhs.criteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddOrReplaceAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsRequest, rhs: Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsRequest) -> Bool {
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddOrReplaceAnnotationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsResponse, rhs: Rideos_MapAnnotation_V1_AddOrReplaceAnnotationsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAnnotationRequest, rhs: Rideos_MapAnnotation_V1_GetAnnotationRequest) -> Bool {
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAnnotationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAnnotationResponse, rhs: Rideos_MapAnnotation_V1_GetAnnotationResponse) -> Bool {
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAllAnnotationIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAllAnnotationIdsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAllAnnotationIdsRequest, rhs: Rideos_MapAnnotation_V1_GetAllAnnotationIdsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAllAnnotationIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAllAnnotationIdsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.annotationIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.annotationIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAllAnnotationIdsResponse, rhs: Rideos_MapAnnotation_V1_GetAllAnnotationIdsResponse) -> Bool {
    if lhs.annotationIds != rhs.annotationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_DeleteAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_DeleteAnnotationRequest, rhs: Rideos_MapAnnotation_V1_DeleteAnnotationRequest) -> Bool {
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_DeleteAnnotationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_DeleteAnnotationResponse, rhs: Rideos_MapAnnotation_V1_DeleteAnnotationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_MatchAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_MatchAnnotationRequest, rhs: Rideos_MapAnnotation_V1_MatchAnnotationRequest) -> Bool {
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_MatchAnnotationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchAnnotationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "edges_geometry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.edgesGeometry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.edgesGeometry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edgesGeometry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_MatchAnnotationResponse, rhs: Rideos_MapAnnotation_V1_MatchAnnotationResponse) -> Bool {
    if lhs.edgesGeometry != rhs.edgesGeometry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAllAnnotationsInAreaRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "area"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._area) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._area {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaRequest, rhs: Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaRequest) -> Bool {
    if lhs._area != rhs._area {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAllAnnotationsInAreaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaResponse, rhs: Rideos_MapAnnotation_V1_GetAllAnnotationsInAreaResponse) -> Bool {
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAnnotationStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAnnotationStatusRequest, rhs: Rideos_MapAnnotation_V1_GetAnnotationStatusRequest) -> Bool {
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_MapAnnotation_V1_GetAnnotationStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_MapAnnotation_V1_GetAnnotationStatusResponse, rhs: Rideos_MapAnnotation_V1_GetAnnotationStatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
