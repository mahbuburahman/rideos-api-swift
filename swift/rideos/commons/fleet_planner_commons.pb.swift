// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rideos/commons/fleet_planner_commons.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2018-2019 rideOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rideos_FleetPlannerCommons_EtaPredictionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Uses up to date, real time traffic speeds from mantis
  case realTimeTraffic // = 0

  /// Uses the default speeds on the map to generate speeds; this will still make a call to mantis
  case staticTraffic // = 1

  /// Calculates the haversine distance between points and multiplies by a fudge factor with standard
  /// speed to predict the time cost.
  case haversine // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .realTimeTraffic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .realTimeTraffic
    case 1: self = .staticTraffic
    case 2: self = .haversine
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .realTimeTraffic: return 0
    case .staticTraffic: return 1
    case .haversine: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rideos_FleetPlannerCommons_EtaPredictionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_FleetPlannerCommons_EtaPredictionType] = [
    .realTimeTraffic,
    .staticTraffic,
    .haversine,
  ]
}

#endif  // swift(>=4.2)

/// An optimization profile is used in Fleet Planner to determine the type of cost function used.
public enum Rideos_FleetPlannerCommons_OptimizationProfile: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// RIDE_HAIL is used by default.
  case `default` // = 0

  /// An optimization profile used for Ride Hail. Minimizes rider wait times and ride times.
  case rideHail // = 1

  /// An optimization profile used for the goods delivery use case. Minimizes total time vehicle spends traveling.
  case goods // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .rideHail
    case 2: self = .goods
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .rideHail: return 1
    case .goods: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rideos_FleetPlannerCommons_OptimizationProfile: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_FleetPlannerCommons_OptimizationProfile] = [
    .default,
    .rideHail,
    .goods,
  ]
}

#endif  // swift(>=4.2)

/// Reason for unresolvable state
public struct Rideos_FleetPlannerCommons_UnresolvableReason {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reason why vehicles could not satisfy a given passenger constraint.
  public var unresolvableReasonType: Rideos_FleetPlannerCommons_UnresolvableReason.TypeEnum = .unknown

  /// Number of vehicles with the above reason.
  public var vehicleCount: UInt32 = 0

  public var vehiclesReturned: Rideos_FleetPlannerCommons_UnresolvableReason.OneOf_VehiclesReturned? = nil

  /// This is set if and only if each and every vehicle in the fleet is unable to service the task for the above
  /// reason.
  public var everyVehicle: Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle {
    get {
      if case .everyVehicle(let v)? = vehiclesReturned {return v}
      return Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle()
    }
    set {vehiclesReturned = .everyVehicle(newValue)}
  }

  /// The specific vehicle ids corresponding to the above reason.
  public var vehicleIds: Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds {
    get {
      if case .vehicleIds(let v)? = vehiclesReturned {return v}
      return Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds()
    }
    set {vehiclesReturned = .vehicleIds(newValue)}
  }

  /// This message is set if the verbose flag was not explicitly passed into the request.
  public var verboseFlagOff: Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff {
    get {
      if case .verboseFlagOff(let v)? = vehiclesReturned {return v}
      return Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff()
    }
    set {vehiclesReturned = .verboseFlagOff(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_VehiclesReturned: Equatable {
    /// This is set if and only if each and every vehicle in the fleet is unable to service the task for the above
    /// reason.
    case everyVehicle(Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle)
    /// The specific vehicle ids corresponding to the above reason.
    case vehicleIds(Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds)
    /// This message is set if the verbose flag was not explicitly passed into the request.
    case verboseFlagOff(Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_FleetPlannerCommons_UnresolvableReason.OneOf_VehiclesReturned, rhs: Rideos_FleetPlannerCommons_UnresolvableReason.OneOf_VehiclesReturned) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.everyVehicle, .everyVehicle): return {
        guard case .everyVehicle(let l) = lhs, case .everyVehicle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleIds, .vehicleIds): return {
        guard case .vehicleIds(let l) = lhs, case .vehicleIds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verboseFlagOff, .verboseFlagOff): return {
        guard case .verboseFlagOff(let l) = lhs, case .verboseFlagOff(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unable to determine why the given count of vehicles could not service the task.
    case unknown // = 0

    /// Vehicles with less than minimum capacity required to service the task.
    case vehiclesWithLowCapacity // = 1

    /// The specific vehicle requested is not currently available. This can happen if
    ///   1) the vehicle is unavailable
    ///   2) the vehicle is available but cannot service the task due to some other issue.
    /// Say N is the number of vehicles in the fleet. In case of #1 the vehicle_count is set to N,
    /// while for #2 the vehicle_count for this reason is set to N-1 and another UnresolvableReason with the
    /// appropriate type is added to the UnresolvedTask with vehicle_count 1 (or more if more vehicles have the same
    /// issue).
    case vehiclesNotMatchingDesiredID // = 2

    /// Vehicles that are available and may be capable of servicing the task but are excluded for the task.
    case vehiclesExcluded // = 3

    /// The trip is feasible but based on current set of constraints some vehicle in the fleet are not capable of
    /// completing the trip. Examples of such constraints are temporary closure of roads, pickup/dropoff is outside
    /// service area, etc.
    case vehiclesCannotCompleteTripRoute // = 4

    /// Either the trip's pickup or dropoff points are unreachable from each other or from any point in the map. For
    /// example, the trip's pickup and dropoff may be in different partitions or separate graph components, or the
    /// pickup or dropoff is somewhere completely unroutable like the ocean.
    case tripIsUnreachable // = 5

    /// There are no vehicles available to service the trip.
    case noVehiclesAreAvailable // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .vehiclesWithLowCapacity
      case 2: self = .vehiclesNotMatchingDesiredID
      case 3: self = .vehiclesExcluded
      case 4: self = .vehiclesCannotCompleteTripRoute
      case 5: self = .tripIsUnreachable
      case 6: self = .noVehiclesAreAvailable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .vehiclesWithLowCapacity: return 1
      case .vehiclesNotMatchingDesiredID: return 2
      case .vehiclesExcluded: return 3
      case .vehiclesCannotCompleteTripRoute: return 4
      case .tripIsUnreachable: return 5
      case .noVehiclesAreAvailable: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct EveryVehicle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct VehicleIds {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var vehicleID: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct VerboseFlagOff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Rideos_FleetPlannerCommons_UnresolvableReason.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_FleetPlannerCommons_UnresolvableReason.TypeEnum] = [
    .unknown,
    .vehiclesWithLowCapacity,
    .vehiclesNotMatchingDesiredID,
    .vehiclesExcluded,
    .vehiclesCannotCompleteTripRoute,
    .tripIsUnreachable,
    .noVehiclesAreAvailable,
  ]
}

#endif  // swift(>=4.2)

public struct Rideos_FleetPlannerCommons_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Rideos_FleetPlannerCommons_Status.TypeEnum = .unknown

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case infeasibleInitialVehicleSolution // = 2
    case invalidRequest // = 3

    /// Currently we use this internally to rethrow an exception.
    case internalError // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .infeasibleInitialVehicleSolution
      case 3: self = .invalidRequest
      case 4: self = .internalError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .infeasibleInitialVehicleSolution: return 2
      case .invalidRequest: return 3
      case .internalError: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Rideos_FleetPlannerCommons_Status.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_FleetPlannerCommons_Status.TypeEnum] = [
    .unknown,
    .success,
    .infeasibleInitialVehicleSolution,
    .invalidRequest,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for controlling vehicle reassignment.
public struct Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set to true, vehicle reassignment happens for trips only if the wait time for pickup decreases or stays the
  /// same.
  public var disallowReassignmentWhenWaitTimeIncreases: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _disallowReassignmentWhenWaitTimeIncreases ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_disallowReassignmentWhenWaitTimeIncreases = newValue}
  }
  /// Returns true if `disallowReassignmentWhenWaitTimeIncreases` has been explicitly set.
  public var hasDisallowReassignmentWhenWaitTimeIncreases: Bool {return self._disallowReassignmentWhenWaitTimeIncreases != nil}
  /// Clears the value of `disallowReassignmentWhenWaitTimeIncreases`. Subsequent reads from it will return its default value.
  public mutating func clearDisallowReassignmentWhenWaitTimeIncreases() {self._disallowReassignmentWhenWaitTimeIncreases = nil}

  /// Wait time threshold in seconds below which vehicle reassignment will not be allowed for a trip.
  /// e.g. If the threshold is set to 2 minutes then any trip which has the vehicle less than or equal to 2 minutes
  /// away from pickup for that trip will not be reassigned to a different vehicle.
  /// If not set, the default value will be 2 Minutes.
  public var waitTimeThresholdForReassignment: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _waitTimeThresholdForReassignment ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_waitTimeThresholdForReassignment = newValue}
  }
  /// Returns true if `waitTimeThresholdForReassignment` has been explicitly set.
  public var hasWaitTimeThresholdForReassignment: Bool {return self._waitTimeThresholdForReassignment != nil}
  /// Clears the value of `waitTimeThresholdForReassignment`. Subsequent reads from it will return its default value.
  public mutating func clearWaitTimeThresholdForReassignment() {self._waitTimeThresholdForReassignment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _disallowReassignmentWhenWaitTimeIncreases: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _waitTimeThresholdForReassignment: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A collection of resources of the same type.
public struct Rideos_FleetPlannerCommons_ResourceAndCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for the resource.
  public var resourceID: String = String()

  /// Count for the given resource.
  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines the capacity of the vehicle in terms of a single capacity impact type. To satisfy
/// capacity constraint for a vehicle every capacity limit within it must be satisfied.
public struct Rideos_FleetPlannerCommons_CapacityLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of capacity impact being tracked. E.g. Monetary amount, size, weight, etc.
  public var capacityImpactType: String = String()

  /// Limit for the given capacity impact. In order to check if a vehicle can accommodate a new task,
  /// the capacity impact for resources requested in each assigned and potential tasks
  /// for a given vehicle is summed up and compared against the limit per capacity impact type.
  public var limit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Uniquely defines an item and its attributes.
public struct Rideos_FleetPlannerCommons_Resource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for a resource. For a generic resource it should identify the type of resource, for a unique
  /// resource it must identify that instance of resource.
  /// E.g.
  /// Generic resource: Kellog's Cornflakes 350g, Organic milk 1 gallon, etc. This is analogous to the barcode
  /// for items in a store.
  /// Unique resource: Passenger user id, Package tracking code, Order Id, etc.
  public var id: String = String()

  /// Capacity cost attributes associated with this resource.
  public var resourceCapacityImpact: [Rideos_FleetPlannerCommons_CapacityImpact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines the impact of adding a given resource instance to a vehicle in terms of
/// its capacity along a single dimension. The resource can have one or more types
/// of impact to the capacity.
/// This abstracts the mapping from a resource to the capacity that it consumes by
/// translating the impact into a quantifiable value that can be compared across items
/// of different resource types.
public struct Rideos_FleetPlannerCommons_CapacityImpact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of impact to vehicle capacity that can be attributed to the item. E.g. Dollar amount, size,
  /// weight, etc.
  public var type: String = String()

  /// The value associated with this type of cost. E.g. $35, 1000cc, 5Kg, etc.
  public var value: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Returns the latency for each major part of the Fleet Planner response calculation.
public struct Rideos_FleetPlannerCommons_Latency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeCostMatrixLatencyInMs: Double = 0

  public var darperLatencyInMs: Double = 0

  public var totalLatencyInMs: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rideos.fleet_planner_commons"

extension Rideos_FleetPlannerCommons_EtaPredictionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REAL_TIME_TRAFFIC"),
    1: .same(proto: "STATIC_TRAFFIC"),
    2: .same(proto: "HAVERSINE"),
  ]
}

extension Rideos_FleetPlannerCommons_OptimizationProfile: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "RIDE_HAIL"),
    2: .same(proto: "GOODS"),
  ]
}

extension Rideos_FleetPlannerCommons_UnresolvableReason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnresolvableReason"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unresolvable_reason_type"),
    2: .standard(proto: "vehicle_count"),
    3: .standard(proto: "every_vehicle"),
    4: .standard(proto: "vehicle_ids"),
    5: .standard(proto: "verbose_flag_off"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.unresolvableReasonType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vehicleCount) }()
      case 3: try {
        var v: Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle?
        if let current = self.vehiclesReturned {
          try decoder.handleConflictingOneOf()
          if case .everyVehicle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.vehiclesReturned = .everyVehicle(v)}
      }()
      case 4: try {
        var v: Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds?
        if let current = self.vehiclesReturned {
          try decoder.handleConflictingOneOf()
          if case .vehicleIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.vehiclesReturned = .vehicleIds(v)}
      }()
      case 5: try {
        var v: Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff?
        if let current = self.vehiclesReturned {
          try decoder.handleConflictingOneOf()
          if case .verboseFlagOff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.vehiclesReturned = .verboseFlagOff(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unresolvableReasonType != .unknown {
      try visitor.visitSingularEnumField(value: self.unresolvableReasonType, fieldNumber: 1)
    }
    if self.vehicleCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.vehicleCount, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.vehiclesReturned {
    case .everyVehicle?: try {
      guard case .everyVehicle(let v)? = self.vehiclesReturned else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .vehicleIds?: try {
      guard case .vehicleIds(let v)? = self.vehiclesReturned else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .verboseFlagOff?: try {
      guard case .verboseFlagOff(let v)? = self.vehiclesReturned else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_UnresolvableReason, rhs: Rideos_FleetPlannerCommons_UnresolvableReason) -> Bool {
    if lhs.unresolvableReasonType != rhs.unresolvableReasonType {return false}
    if lhs.vehicleCount != rhs.vehicleCount {return false}
    if lhs.vehiclesReturned != rhs.vehiclesReturned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_UnresolvableReason.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "VEHICLES_WITH_LOW_CAPACITY"),
    2: .same(proto: "VEHICLES_NOT_MATCHING_DESIRED_ID"),
    3: .same(proto: "VEHICLES_EXCLUDED"),
    4: .same(proto: "VEHICLES_CANNOT_COMPLETE_TRIP_ROUTE"),
    5: .same(proto: "TRIP_IS_UNREACHABLE"),
    6: .same(proto: "NO_VEHICLES_ARE_AVAILABLE"),
  ]
}

extension Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_FleetPlannerCommons_UnresolvableReason.protoMessageName + ".EveryVehicle"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle, rhs: Rideos_FleetPlannerCommons_UnresolvableReason.EveryVehicle) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_FleetPlannerCommons_UnresolvableReason.protoMessageName + ".VehicleIds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.vehicleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.vehicleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds, rhs: Rideos_FleetPlannerCommons_UnresolvableReason.VehicleIds) -> Bool {
    if lhs.vehicleID != rhs.vehicleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rideos_FleetPlannerCommons_UnresolvableReason.protoMessageName + ".VerboseFlagOff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff, rhs: Rideos_FleetPlannerCommons_UnresolvableReason.VerboseFlagOff) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_Status, rhs: Rideos_FleetPlannerCommons_Status) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_Status.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "INFEASIBLE_INITIAL_VEHICLE_SOLUTION"),
    3: .same(proto: "INVALID_REQUEST"),
    4: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehicleReassignmentConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disallow_reassignment_when_wait_time_increases"),
    2: .standard(proto: "wait_time_threshold_for_reassignment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._disallowReassignmentWhenWaitTimeIncreases) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._waitTimeThresholdForReassignment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._disallowReassignmentWhenWaitTimeIncreases {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._waitTimeThresholdForReassignment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration, rhs: Rideos_FleetPlannerCommons_VehicleReassignmentConfiguration) -> Bool {
    if lhs._disallowReassignmentWhenWaitTimeIncreases != rhs._disallowReassignmentWhenWaitTimeIncreases {return false}
    if lhs._waitTimeThresholdForReassignment != rhs._waitTimeThresholdForReassignment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_ResourceAndCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceAndCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_id"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_ResourceAndCount, rhs: Rideos_FleetPlannerCommons_ResourceAndCount) -> Bool {
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_CapacityLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CapacityLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "capacity_impact_type"),
    2: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.capacityImpactType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.capacityImpactType.isEmpty {
      try visitor.visitSingularStringField(value: self.capacityImpactType, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_CapacityLimit, rhs: Rideos_FleetPlannerCommons_CapacityLimit) -> Bool {
    if lhs.capacityImpactType != rhs.capacityImpactType {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "resource_capacity_impact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.resourceCapacityImpact) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.resourceCapacityImpact.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceCapacityImpact, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_Resource, rhs: Rideos_FleetPlannerCommons_Resource) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.resourceCapacityImpact != rhs.resourceCapacityImpact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_CapacityImpact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CapacityImpact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_CapacityImpact, rhs: Rideos_FleetPlannerCommons_CapacityImpact) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_FleetPlannerCommons_Latency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Latency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_cost_matrix_latency_in_ms"),
    2: .standard(proto: "darper_latency_in_ms"),
    3: .standard(proto: "total_latency_in_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.timeCostMatrixLatencyInMs) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.darperLatencyInMs) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.totalLatencyInMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeCostMatrixLatencyInMs != 0 {
      try visitor.visitSingularDoubleField(value: self.timeCostMatrixLatencyInMs, fieldNumber: 1)
    }
    if self.darperLatencyInMs != 0 {
      try visitor.visitSingularDoubleField(value: self.darperLatencyInMs, fieldNumber: 2)
    }
    if self.totalLatencyInMs != 0 {
      try visitor.visitSingularDoubleField(value: self.totalLatencyInMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_FleetPlannerCommons_Latency, rhs: Rideos_FleetPlannerCommons_Latency) -> Bool {
    if lhs.timeCostMatrixLatencyInMs != rhs.timeCostMatrixLatencyInMs {return false}
    if lhs.darperLatencyInMs != rhs.darperLatencyInMs {return false}
    if lhs.totalLatencyInMs != rhs.totalLatencyInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
