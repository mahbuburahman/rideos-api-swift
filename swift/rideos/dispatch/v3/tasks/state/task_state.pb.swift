// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rideos/dispatch/v3/tasks/state/task_state.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2018-2019 rideOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rideos_Dispatch_V3_Tasks_State_CancelSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case requestor // = 1
  case vehicle // = 2
  case `operator` // = 3
  case other // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .requestor
    case 2: self = .vehicle
    case 3: self = .operator
    case 4: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .requestor: return 1
    case .vehicle: return 2
    case .operator: return 3
    case .other: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rideos_Dispatch_V3_Tasks_State_CancelSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_Dispatch_V3_Tasks_State_CancelSource] = [
    .unknown,
    .requestor,
    .vehicle,
    .operator,
    .other,
  ]
}

#endif  // swift(>=4.2)

/// The task state represents the progress made in completing a given task. A task can either be "in progress",
/// "cancelled", or "completed". When in progress, the step completion state can be used to see how far along the task
/// is in being completed. The assignment field can be used to determine whether or not a vehicle has been assigned
/// to a task using our optimization engine.
public struct Rideos_Dispatch_V3_Tasks_State_TaskState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stage: Rideos_Dispatch_V3_Tasks_State_TaskState.OneOf_Stage? = nil

  public var inProgress: Rideos_Dispatch_V3_Tasks_State_InProgressStage {
    get {
      if case .inProgress(let v)? = stage {return v}
      return Rideos_Dispatch_V3_Tasks_State_InProgressStage()
    }
    set {stage = .inProgress(newValue)}
  }

  public var canceled: Rideos_Dispatch_V3_Tasks_State_CancellationStage {
    get {
      if case .canceled(let v)? = stage {return v}
      return Rideos_Dispatch_V3_Tasks_State_CancellationStage()
    }
    set {stage = .canceled(newValue)}
  }

  public var replaced: Rideos_Dispatch_V3_Tasks_State_ReplacementStage {
    get {
      if case .replaced(let v)? = stage {return v}
      return Rideos_Dispatch_V3_Tasks_State_ReplacementStage()
    }
    set {stage = .replaced(newValue)}
  }

  public var completed: Rideos_Dispatch_V3_Tasks_State_CompletionStage {
    get {
      if case .completed(let v)? = stage {return v}
      return Rideos_Dispatch_V3_Tasks_State_CompletionStage()
    }
    set {stage = .completed(newValue)}
  }

  public var assignment: Rideos_Dispatch_V3_Tasks_State_Assignment {
    get {return _assignment ?? Rideos_Dispatch_V3_Tasks_State_Assignment()}
    set {_assignment = newValue}
  }
  /// Returns true if `assignment` has been explicitly set.
  public var hasAssignment: Bool {return self._assignment != nil}
  /// Clears the value of `assignment`. Subsequent reads from it will return its default value.
  public mutating func clearAssignment() {self._assignment = nil}

  public var stepCompletionState: Rideos_Dispatch_V3_Tasks_State_StepCompletionState {
    get {return _stepCompletionState ?? Rideos_Dispatch_V3_Tasks_State_StepCompletionState()}
    set {_stepCompletionState = newValue}
  }
  /// Returns true if `stepCompletionState` has been explicitly set.
  public var hasStepCompletionState: Bool {return self._stepCompletionState != nil}
  /// Clears the value of `stepCompletionState`. Subsequent reads from it will return its default value.
  public mutating func clearStepCompletionState() {self._stepCompletionState = nil}

  /// Stores vehicle rejections
  public var vehicleRejections: [Rideos_Dispatch_V3_Tasks_State_VehicleRejection] = []

  public var excludedVehicles: Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles {
    get {return _excludedVehicles ?? Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles()}
    set {_excludedVehicles = newValue}
  }
  /// Returns true if `excludedVehicles` has been explicitly set.
  public var hasExcludedVehicles: Bool {return self._excludedVehicles != nil}
  /// Clears the value of `excludedVehicles`. Subsequent reads from it will return its default value.
  public mutating func clearExcludedVehicles() {self._excludedVehicles = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Stage: Equatable {
    case inProgress(Rideos_Dispatch_V3_Tasks_State_InProgressStage)
    case canceled(Rideos_Dispatch_V3_Tasks_State_CancellationStage)
    case replaced(Rideos_Dispatch_V3_Tasks_State_ReplacementStage)
    case completed(Rideos_Dispatch_V3_Tasks_State_CompletionStage)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_TaskState.OneOf_Stage, rhs: Rideos_Dispatch_V3_Tasks_State_TaskState.OneOf_Stage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inProgress, .inProgress): return {
        guard case .inProgress(let l) = lhs, case .inProgress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.canceled, .canceled): return {
        guard case .canceled(let l) = lhs, case .canceled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.replaced, .replaced): return {
        guard case .replaced(let l) = lhs, case .replaced(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.completed, .completed): return {
        guard case .completed(let l) = lhs, case .completed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _assignment: Rideos_Dispatch_V3_Tasks_State_Assignment? = nil
  fileprivate var _stepCompletionState: Rideos_Dispatch_V3_Tasks_State_StepCompletionState? = nil
  fileprivate var _excludedVehicles: Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles? = nil
}

/// An assignment may or may not exist for a task and is strictly read-only. If the assignment field is not filled out,
/// this means that the task has not yet been assigned to any vehicle. The list of unresolvable reasons can be used
/// when the task is in the "in progress" stage.
public struct Rideos_Dispatch_V3_Tasks_State_Assignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assignedVehicleID: String = String()

  public var timeOfLastAssignment: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeOfLastAssignment ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeOfLastAssignment = newValue}
  }
  /// Returns true if `timeOfLastAssignment` has been explicitly set.
  public var hasTimeOfLastAssignment: Bool {return self._timeOfLastAssignment != nil}
  /// Clears the value of `timeOfLastAssignment`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfLastAssignment() {self._timeOfLastAssignment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfLastAssignment: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Task has steps that still need to be completed. This contains any reasons why the task has not been assigned if it
/// has been run through optimization. All step state is within the step completion state
public struct Rideos_Dispatch_V3_Tasks_State_InProgressStage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. If a Fleet Planner run could not resolve this task, the corresponding reasons are listed here.
  public var unresolvableReason: [Rideos_FleetPlannerCommons_UnresolvableReason] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_State_ReplacementStage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replacementTaskID: String = String()

  public var timeOfReplacement: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeOfReplacement ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeOfReplacement = newValue}
  }
  /// Returns true if `timeOfReplacement` has been explicitly set.
  public var hasTimeOfReplacement: Bool {return self._timeOfReplacement != nil}
  /// Clears the value of `timeOfReplacement`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfReplacement() {self._timeOfReplacement = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfReplacement: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Task has been cancelled
public struct Rideos_Dispatch_V3_Tasks_State_CancellationStage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: Rideos_Dispatch_V3_Tasks_State_CancelSource = .unknown

  public var description_p: String = String()

  public var timeOfCancellation: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeOfCancellation ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeOfCancellation = newValue}
  }
  /// Returns true if `timeOfCancellation` has been explicitly set.
  public var hasTimeOfCancellation: Bool {return self._timeOfCancellation != nil}
  /// Clears the value of `timeOfCancellation`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfCancellation() {self._timeOfCancellation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfCancellation: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// All task steps have been completed
public struct Rideos_Dispatch_V3_Tasks_State_CompletionStage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeOfCompletion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeOfCompletion = newValue}
  }
  /// Returns true if `timeOfCompletion` has been explicitly set.
  public var hasTimeOfCompletion: Bool {return self._timeOfCompletion != nil}
  /// Clears the value of `timeOfCompletion`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfCompletion() {self._timeOfCompletion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Defines which steps have been completed and when. Steps must be completed in order, but multiple steps can be completed at once
public struct Rideos_Dispatch_V3_Tasks_State_StepCompletionState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskStepType: Rideos_Dispatch_V3_Tasks_State_StepCompletionState.OneOf_TaskStepType? = nil

  public var pickupDropoffTask: Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState {
    get {
      if case .pickupDropoffTask(let v)? = taskStepType {return v}
      return Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState()
    }
    set {taskStepType = .pickupDropoffTask(newValue)}
  }

  public var operationalTask: Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState {
    get {
      if case .operationalTask(let v)? = taskStepType {return v}
      return Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState()
    }
    set {taskStepType = .operationalTask(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TaskStepType: Equatable {
    case pickupDropoffTask(Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState)
    case operationalTask(Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_StepCompletionState.OneOf_TaskStepType, rhs: Rideos_Dispatch_V3_Tasks_State_StepCompletionState.OneOf_TaskStepType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pickupDropoffTask, .pickupDropoffTask): return {
        guard case .pickupDropoffTask(let l) = lhs, case .pickupDropoffTask(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operationalTask, .operationalTask): return {
        guard case .operationalTask(let l) = lhs, case .operationalTask(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_State_StepState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stepID: String = String()

  public var completed: Bool = false

  /// Time that the step was actually completed
  public var timeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeOfCompletion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeOfCompletion = newValue}
  }
  /// Returns true if `timeOfCompletion` has been explicitly set.
  public var hasTimeOfCompletion: Bool {return self._timeOfCompletion != nil}
  /// Clears the value of `timeOfCompletion`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfCompletion() {self._timeOfCompletion = nil}

  /// Estimated time this would be completed by a vehicle, if the estimate exists
  public var estimatedTimeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _estimatedTimeOfCompletion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_estimatedTimeOfCompletion = newValue}
  }
  /// Returns true if `estimatedTimeOfCompletion` has been explicitly set.
  public var hasEstimatedTimeOfCompletion: Bool {return self._estimatedTimeOfCompletion != nil}
  /// Clears the value of `estimatedTimeOfCompletion`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedTimeOfCompletion() {self._estimatedTimeOfCompletion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _estimatedTimeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Gives the completion state of each step in a pickup/drop-off task. This can be used to determine the progress made
/// to the given task. For example, if "driveToPickup" is completed, then the task is in the "picking up resource" phase.
public struct Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var driveToPickup: Rideos_Dispatch_V3_Tasks_State_StepState {
    get {return _storage._driveToPickup ?? Rideos_Dispatch_V3_Tasks_State_StepState()}
    set {_uniqueStorage()._driveToPickup = newValue}
  }
  /// Returns true if `driveToPickup` has been explicitly set.
  public var hasDriveToPickup: Bool {return _storage._driveToPickup != nil}
  /// Clears the value of `driveToPickup`. Subsequent reads from it will return its default value.
  public mutating func clearDriveToPickup() {_uniqueStorage()._driveToPickup = nil}

  public var pickupResource: Rideos_Dispatch_V3_Tasks_State_StepState {
    get {return _storage._pickupResource ?? Rideos_Dispatch_V3_Tasks_State_StepState()}
    set {_uniqueStorage()._pickupResource = newValue}
  }
  /// Returns true if `pickupResource` has been explicitly set.
  public var hasPickupResource: Bool {return _storage._pickupResource != nil}
  /// Clears the value of `pickupResource`. Subsequent reads from it will return its default value.
  public mutating func clearPickupResource() {_uniqueStorage()._pickupResource = nil}

  public var driveToDropoff: Rideos_Dispatch_V3_Tasks_State_StepState {
    get {return _storage._driveToDropoff ?? Rideos_Dispatch_V3_Tasks_State_StepState()}
    set {_uniqueStorage()._driveToDropoff = newValue}
  }
  /// Returns true if `driveToDropoff` has been explicitly set.
  public var hasDriveToDropoff: Bool {return _storage._driveToDropoff != nil}
  /// Clears the value of `driveToDropoff`. Subsequent reads from it will return its default value.
  public mutating func clearDriveToDropoff() {_uniqueStorage()._driveToDropoff = nil}

  public var dropoffResource: Rideos_Dispatch_V3_Tasks_State_StepState {
    get {return _storage._dropoffResource ?? Rideos_Dispatch_V3_Tasks_State_StepState()}
    set {_uniqueStorage()._dropoffResource = newValue}
  }
  /// Returns true if `dropoffResource` has been explicitly set.
  public var hasDropoffResource: Bool {return _storage._dropoffResource != nil}
  /// Clears the value of `dropoffResource`. Subsequent reads from it will return its default value.
  public mutating func clearDropoffResource() {_uniqueStorage()._dropoffResource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var driveToLocation: Rideos_Dispatch_V3_Tasks_State_StepState {
    get {return _driveToLocation ?? Rideos_Dispatch_V3_Tasks_State_StepState()}
    set {_driveToLocation = newValue}
  }
  /// Returns true if `driveToLocation` has been explicitly set.
  public var hasDriveToLocation: Bool {return self._driveToLocation != nil}
  /// Clears the value of `driveToLocation`. Subsequent reads from it will return its default value.
  public mutating func clearDriveToLocation() {self._driveToLocation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _driveToLocation: Rideos_Dispatch_V3_Tasks_State_StepState? = nil
}

/// List of vehicles that cannot be assigned to this task
public struct Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vehicleIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_State_VehicleRejection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rejectingVehicleID: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rideos.dispatch.v3.tasks.state"

extension Rideos_Dispatch_V3_Tasks_State_CancelSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REQUESTOR"),
    2: .same(proto: "VEHICLE"),
    3: .same(proto: "OPERATOR"),
    4: .same(proto: "OTHER"),
  ]
}

extension Rideos_Dispatch_V3_Tasks_State_TaskState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "in_progress"),
    2: .same(proto: "canceled"),
    3: .same(proto: "replaced"),
    4: .same(proto: "completed"),
    5: .same(proto: "assignment"),
    6: .standard(proto: "step_completion_state"),
    8: .standard(proto: "vehicle_rejections"),
    9: .standard(proto: "excluded_vehicles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rideos_Dispatch_V3_Tasks_State_InProgressStage?
        if let current = self.stage {
          try decoder.handleConflictingOneOf()
          if case .inProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stage = .inProgress(v)}
      }()
      case 2: try {
        var v: Rideos_Dispatch_V3_Tasks_State_CancellationStage?
        if let current = self.stage {
          try decoder.handleConflictingOneOf()
          if case .canceled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stage = .canceled(v)}
      }()
      case 3: try {
        var v: Rideos_Dispatch_V3_Tasks_State_ReplacementStage?
        if let current = self.stage {
          try decoder.handleConflictingOneOf()
          if case .replaced(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stage = .replaced(v)}
      }()
      case 4: try {
        var v: Rideos_Dispatch_V3_Tasks_State_CompletionStage?
        if let current = self.stage {
          try decoder.handleConflictingOneOf()
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stage = .completed(v)}
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._assignment) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stepCompletionState) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.vehicleRejections) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._excludedVehicles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.stage {
    case .inProgress?: try {
      guard case .inProgress(let v)? = self.stage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .canceled?: try {
      guard case .canceled(let v)? = self.stage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .replaced?: try {
      guard case .replaced(let v)? = self.stage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .completed?: try {
      guard case .completed(let v)? = self.stage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if let v = self._assignment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._stepCompletionState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.vehicleRejections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vehicleRejections, fieldNumber: 8)
    }
    if let v = self._excludedVehicles {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_TaskState, rhs: Rideos_Dispatch_V3_Tasks_State_TaskState) -> Bool {
    if lhs.stage != rhs.stage {return false}
    if lhs._assignment != rhs._assignment {return false}
    if lhs._stepCompletionState != rhs._stepCompletionState {return false}
    if lhs.vehicleRejections != rhs.vehicleRejections {return false}
    if lhs._excludedVehicles != rhs._excludedVehicles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_Assignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Assignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "assigned_vehicle_id"),
    2: .standard(proto: "time_of_last_assignment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.assignedVehicleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeOfLastAssignment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignedVehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.assignedVehicleID, fieldNumber: 1)
    }
    if let v = self._timeOfLastAssignment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_Assignment, rhs: Rideos_Dispatch_V3_Tasks_State_Assignment) -> Bool {
    if lhs.assignedVehicleID != rhs.assignedVehicleID {return false}
    if lhs._timeOfLastAssignment != rhs._timeOfLastAssignment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_InProgressStage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InProgressStage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unresolvable_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.unresolvableReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unresolvableReason.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unresolvableReason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_InProgressStage, rhs: Rideos_Dispatch_V3_Tasks_State_InProgressStage) -> Bool {
    if lhs.unresolvableReason != rhs.unresolvableReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_ReplacementStage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplacementStage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replacement_task_id"),
    2: .standard(proto: "time_of_replacement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.replacementTaskID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeOfReplacement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.replacementTaskID.isEmpty {
      try visitor.visitSingularStringField(value: self.replacementTaskID, fieldNumber: 1)
    }
    if let v = self._timeOfReplacement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_ReplacementStage, rhs: Rideos_Dispatch_V3_Tasks_State_ReplacementStage) -> Bool {
    if lhs.replacementTaskID != rhs.replacementTaskID {return false}
    if lhs._timeOfReplacement != rhs._timeOfReplacement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_CancellationStage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancellationStage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "description"),
    3: .standard(proto: "time_of_cancellation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeOfCancellation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._timeOfCancellation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_CancellationStage, rhs: Rideos_Dispatch_V3_Tasks_State_CancellationStage) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._timeOfCancellation != rhs._timeOfCancellation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_CompletionStage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompletionStage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_of_completion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeOfCompletion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timeOfCompletion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_CompletionStage, rhs: Rideos_Dispatch_V3_Tasks_State_CompletionStage) -> Bool {
    if lhs._timeOfCompletion != rhs._timeOfCompletion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_StepCompletionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StepCompletionState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pickup_dropoff_task"),
    2: .standard(proto: "operational_task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState?
        if let current = self.taskStepType {
          try decoder.handleConflictingOneOf()
          if case .pickupDropoffTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.taskStepType = .pickupDropoffTask(v)}
      }()
      case 2: try {
        var v: Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState?
        if let current = self.taskStepType {
          try decoder.handleConflictingOneOf()
          if case .operationalTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.taskStepType = .operationalTask(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.taskStepType {
    case .pickupDropoffTask?: try {
      guard case .pickupDropoffTask(let v)? = self.taskStepType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .operationalTask?: try {
      guard case .operationalTask(let v)? = self.taskStepType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_StepCompletionState, rhs: Rideos_Dispatch_V3_Tasks_State_StepCompletionState) -> Bool {
    if lhs.taskStepType != rhs.taskStepType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_StepState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StepState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_id"),
    2: .same(proto: "completed"),
    3: .standard(proto: "time_of_completion"),
    4: .standard(proto: "estimated_time_of_completion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stepID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.completed) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeOfCompletion) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._estimatedTimeOfCompletion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stepID.isEmpty {
      try visitor.visitSingularStringField(value: self.stepID, fieldNumber: 1)
    }
    if self.completed != false {
      try visitor.visitSingularBoolField(value: self.completed, fieldNumber: 2)
    }
    if let v = self._timeOfCompletion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._estimatedTimeOfCompletion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_StepState, rhs: Rideos_Dispatch_V3_Tasks_State_StepState) -> Bool {
    if lhs.stepID != rhs.stepID {return false}
    if lhs.completed != rhs.completed {return false}
    if lhs._timeOfCompletion != rhs._timeOfCompletion {return false}
    if lhs._estimatedTimeOfCompletion != rhs._estimatedTimeOfCompletion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickupDropoffTaskStepState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "drive_to_pickup"),
    2: .standard(proto: "pickup_resource"),
    3: .standard(proto: "drive_to_dropoff"),
    4: .standard(proto: "dropoff_resource"),
  ]

  fileprivate class _StorageClass {
    var _driveToPickup: Rideos_Dispatch_V3_Tasks_State_StepState? = nil
    var _pickupResource: Rideos_Dispatch_V3_Tasks_State_StepState? = nil
    var _driveToDropoff: Rideos_Dispatch_V3_Tasks_State_StepState? = nil
    var _dropoffResource: Rideos_Dispatch_V3_Tasks_State_StepState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _driveToPickup = source._driveToPickup
      _pickupResource = source._pickupResource
      _driveToDropoff = source._driveToDropoff
      _dropoffResource = source._dropoffResource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._driveToPickup) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pickupResource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._driveToDropoff) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dropoffResource) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._driveToPickup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pickupResource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._driveToDropoff {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._dropoffResource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState, rhs: Rideos_Dispatch_V3_Tasks_State_PickupDropoffTaskStepState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._driveToPickup != rhs_storage._driveToPickup {return false}
        if _storage._pickupResource != rhs_storage._pickupResource {return false}
        if _storage._driveToDropoff != rhs_storage._driveToDropoff {return false}
        if _storage._dropoffResource != rhs_storage._dropoffResource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationalTaskStepState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "drive_to_location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._driveToLocation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._driveToLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState, rhs: Rideos_Dispatch_V3_Tasks_State_OperationalTaskStepState) -> Bool {
    if lhs._driveToLocation != rhs._driveToLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExcludedVehicles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.vehicleIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.vehicleIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles, rhs: Rideos_Dispatch_V3_Tasks_State_ExcludedVehicles) -> Bool {
    if lhs.vehicleIds != rhs.vehicleIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_State_VehicleRejection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehicleRejection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rejecting_vehicle_id"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rejectingVehicleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rejectingVehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectingVehicleID, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_State_VehicleRejection, rhs: Rideos_Dispatch_V3_Tasks_State_VehicleRejection) -> Bool {
    if lhs.rejectingVehicleID != rhs.rejectingVehicleID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
