// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rideos/dispatch/v3/tasks/task.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2018-2019 rideOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// setting for how pooling should be handled for this task
public enum Rideos_Dispatch_V3_Tasks_TaskPoolingSetting: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// use the fleet's default setting for task pooling
  case fleetDefault // = 0

  /// task will not share a vehicle with any others
  /// task may be pooled with other tasks
  case pooled // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .fleetDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fleetDefault
    case 2: self = .pooled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fleetDefault: return 0
    case .pooled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rideos_Dispatch_V3_Tasks_TaskPoolingSetting: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_Dispatch_V3_Tasks_TaskPoolingSetting] = [
    .fleetDefault,
    .pooled,
  ]
}

#endif  // swift(>=4.2)

public struct Rideos_Dispatch_V3_Tasks_Task {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String {
    get {return _storage._taskID}
    set {_uniqueStorage()._taskID = newValue}
  }

  public var fleetID: String {
    get {return _storage._fleetID}
    set {_uniqueStorage()._fleetID = newValue}
  }

  public var taskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinition {
    get {return _storage._taskDefinition ?? Rideos_Dispatch_V3_Tasks_TaskDefinition()}
    set {_uniqueStorage()._taskDefinition = newValue}
  }
  /// Returns true if `taskDefinition` has been explicitly set.
  public var hasTaskDefinition: Bool {return _storage._taskDefinition != nil}
  /// Clears the value of `taskDefinition`. Subsequent reads from it will return its default value.
  public mutating func clearTaskDefinition() {_uniqueStorage()._taskDefinition = nil}

  public var metadata: Rideos_Dispatch_V3_Common_Metadata {
    get {return _storage._metadata ?? Rideos_Dispatch_V3_Common_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var creationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._creationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._creationTime = newValue}
  }
  /// Returns true if `creationTime` has been explicitly set.
  public var hasCreationTime: Bool {return _storage._creationTime != nil}
  /// Clears the value of `creationTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreationTime() {_uniqueStorage()._creationTime = nil}

  public var terminationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._terminationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._terminationTime = newValue}
  }
  /// Returns true if `terminationTime` has been explicitly set.
  public var hasTerminationTime: Bool {return _storage._terminationTime != nil}
  /// Clears the value of `terminationTime`. Subsequent reads from it will return its default value.
  public mutating func clearTerminationTime() {_uniqueStorage()._terminationTime = nil}

  public var state: Rideos_Dispatch_V3_Tasks_State_TaskState {
    get {return _storage._state ?? Rideos_Dispatch_V3_Tasks_State_TaskState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rideos_Dispatch_V3_Tasks_TaskDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskDefinition: OneOf_TaskDefinition? {
    get {return _storage._taskDefinition}
    set {_uniqueStorage()._taskDefinition = newValue}
  }

  public var pickupDropoffTask: Rideos_Dispatch_V3_Tasks_PickupDropoffTask {
    get {
      if case .pickupDropoffTask(let v)? = _storage._taskDefinition {return v}
      return Rideos_Dispatch_V3_Tasks_PickupDropoffTask()
    }
    set {_uniqueStorage()._taskDefinition = .pickupDropoffTask(newValue)}
  }

  public var operationalTask: Rideos_Dispatch_V3_Tasks_OperationalTask {
    get {
      if case .operationalTask(let v)? = _storage._taskDefinition {return v}
      return Rideos_Dispatch_V3_Tasks_OperationalTask()
    }
    set {_uniqueStorage()._taskDefinition = .operationalTask(newValue)}
  }

  public var dispatchParameters: Rideos_Dispatch_V3_Tasks_DispatchParameters {
    get {return _storage._dispatchParameters ?? Rideos_Dispatch_V3_Tasks_DispatchParameters()}
    set {_uniqueStorage()._dispatchParameters = newValue}
  }
  /// Returns true if `dispatchParameters` has been explicitly set.
  public var hasDispatchParameters: Bool {return _storage._dispatchParameters != nil}
  /// Clears the value of `dispatchParameters`. Subsequent reads from it will return its default value.
  public mutating func clearDispatchParameters() {_uniqueStorage()._dispatchParameters = nil}

  public var requestorID: String {
    get {return _storage._requestorID}
    set {_uniqueStorage()._requestorID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TaskDefinition: Equatable {
    case pickupDropoffTask(Rideos_Dispatch_V3_Tasks_PickupDropoffTask)
    case operationalTask(Rideos_Dispatch_V3_Tasks_OperationalTask)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TaskDefinition.OneOf_TaskDefinition, rhs: Rideos_Dispatch_V3_Tasks_TaskDefinition.OneOf_TaskDefinition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pickupDropoffTask, .pickupDropoffTask): return {
        guard case .pickupDropoffTask(let l) = lhs, case .pickupDropoffTask(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operationalTask, .operationalTask): return {
        guard case .operationalTask(let l) = lhs, case .operationalTask(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rideos_Dispatch_V3_Tasks_TaskLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Rideos_Dispatch_V3_Tasks_TaskLocation.OneOf_Type? = nil

  public var stopID: SwiftProtobuf.Google_Protobuf_StringValue {
    get {
      if case .stopID(let v)? = type {return v}
      return SwiftProtobuf.Google_Protobuf_StringValue()
    }
    set {type = .stopID(newValue)}
  }

  public var position: Rideos_Geo_V1_Position {
    get {
      if case .position(let v)? = type {return v}
      return Rideos_Geo_V1_Position()
    }
    set {type = .position(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case stopID(SwiftProtobuf.Google_Protobuf_StringValue)
    case position(Rideos_Geo_V1_Position)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TaskLocation.OneOf_Type, rhs: Rideos_Dispatch_V3_Tasks_TaskLocation.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stopID, .stopID): return {
        guard case .stopID(let l) = lhs, case .stopID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// PickupDropoffTasks can pickup two types of resources: unique resources and generic resources. Unique resources
/// must be picked up from a specific location (e.g. passengers, custom orders). Generic resources are serviced
/// using available vehicle inventory, so a pickup location is not specified. A dropoff location is always specified.
public struct Rideos_Dispatch_V3_Tasks_PickupDropoffTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pickupType: Rideos_Dispatch_V3_Tasks_PickupDropoffTask.OneOf_PickupType? = nil

  public var uniqueResourcePickup: Rideos_Dispatch_V3_Tasks_UniqueResourcePickup {
    get {
      if case .uniqueResourcePickup(let v)? = pickupType {return v}
      return Rideos_Dispatch_V3_Tasks_UniqueResourcePickup()
    }
    set {pickupType = .uniqueResourcePickup(newValue)}
  }

  public var genericResourcePickup: Rideos_Dispatch_V3_Tasks_GenericResourcePickup {
    get {
      if case .genericResourcePickup(let v)? = pickupType {return v}
      return Rideos_Dispatch_V3_Tasks_GenericResourcePickup()
    }
    set {pickupType = .genericResourcePickup(newValue)}
  }

  public var dropoff: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _dropoff ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_dropoff = newValue}
  }
  /// Returns true if `dropoff` has been explicitly set.
  public var hasDropoff: Bool {return self._dropoff != nil}
  /// Clears the value of `dropoff`. Subsequent reads from it will return its default value.
  public mutating func clearDropoff() {self._dropoff = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PickupType: Equatable {
    case uniqueResourcePickup(Rideos_Dispatch_V3_Tasks_UniqueResourcePickup)
    case genericResourcePickup(Rideos_Dispatch_V3_Tasks_GenericResourcePickup)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Dispatch_V3_Tasks_PickupDropoffTask.OneOf_PickupType, rhs: Rideos_Dispatch_V3_Tasks_PickupDropoffTask.OneOf_PickupType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uniqueResourcePickup, .uniqueResourcePickup): return {
        guard case .uniqueResourcePickup(let l) = lhs, case .uniqueResourcePickup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genericResourcePickup, .genericResourcePickup): return {
        guard case .genericResourcePickup(let l) = lhs, case .genericResourcePickup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _dropoff: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
}

/// Unique resources are a resource that cannot be interchanged with any other resources. The item must be picked up
/// from a specified location and then dropped off. Examples: passengers, custom food orders
public struct Rideos_Dispatch_V3_Tasks_UniqueResourcePickup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pickupLocation: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _pickupLocation ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_pickupLocation = newValue}
  }
  /// Returns true if `pickupLocation` has been explicitly set.
  public var hasPickupLocation: Bool {return self._pickupLocation != nil}
  /// Clears the value of `pickupLocation`. Subsequent reads from it will return its default value.
  public mutating func clearPickupLocation() {self._pickupLocation = nil}

  public var uniqueResource: Rideos_Dispatch_V3_Common_UniqueResource {
    get {return _uniqueResource ?? Rideos_Dispatch_V3_Common_UniqueResource()}
    set {_uniqueResource = newValue}
  }
  /// Returns true if `uniqueResource` has been explicitly set.
  public var hasUniqueResource: Bool {return self._uniqueResource != nil}
  /// Clears the value of `uniqueResource`. Subsequent reads from it will return its default value.
  public mutating func clearUniqueResource() {self._uniqueResource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pickupLocation: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
  fileprivate var _uniqueResource: Rideos_Dispatch_V3_Common_UniqueResource? = nil
}

/// Generic resources are a resource that can be interchanged with identical items from vehicle inventory. Examples:
/// meal kits, pharmacy items
public struct Rideos_Dispatch_V3_Tasks_GenericResourcePickup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genericResourceGroup: Rideos_Dispatch_V3_Common_GenericResourceGroup {
    get {return _genericResourceGroup ?? Rideos_Dispatch_V3_Common_GenericResourceGroup()}
    set {_genericResourceGroup = newValue}
  }
  /// Returns true if `genericResourceGroup` has been explicitly set.
  public var hasGenericResourceGroup: Bool {return self._genericResourceGroup != nil}
  /// Clears the value of `genericResourceGroup`. Subsequent reads from it will return its default value.
  public mutating func clearGenericResourceGroup() {self._genericResourceGroup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genericResourceGroup: Rideos_Dispatch_V3_Common_GenericResourceGroup? = nil
}

public struct Rideos_Dispatch_V3_Tasks_RiderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contactInfo: Rideos_Dispatch_V3_Common_ContactInfo {
    get {return _contactInfo ?? Rideos_Dispatch_V3_Common_ContactInfo()}
    set {_contactInfo = newValue}
  }
  /// Returns true if `contactInfo` has been explicitly set.
  public var hasContactInfo: Bool {return self._contactInfo != nil}
  /// Clears the value of `contactInfo`. Subsequent reads from it will return its default value.
  public mutating func clearContactInfo() {self._contactInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contactInfo: Rideos_Dispatch_V3_Common_ContactInfo? = nil
}

public struct Rideos_Dispatch_V3_Tasks_OperationalTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stop: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _stop ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_stop = newValue}
  }
  /// Returns true if `stop` has been explicitly set.
  public var hasStop: Bool {return self._stop != nil}
  /// Clears the value of `stop`. Subsequent reads from it will return its default value.
  public mutating func clearStop() {self._stop = nil}

  public var reason: Rideos_Dispatch_V3_Tasks_OperationalTask.Reason = .unknown

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case refuel // = 1
    case repair // = 2
    case custom // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .refuel
      case 2: self = .repair
      case 3: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .refuel: return 1
      case .repair: return 2
      case .custom: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _stop: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
}

#if swift(>=4.2)

extension Rideos_Dispatch_V3_Tasks_OperationalTask.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rideos_Dispatch_V3_Tasks_OperationalTask.Reason] = [
    .unknown,
    .refuel,
    .repair,
    .custom,
  ]
}

#endif  // swift(>=4.2)

/// Options to configure the task assignment
public struct Rideos_Dispatch_V3_Tasks_DispatchParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional maximum duration to wait for an assignment before the task is cancelled
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// Vehicle filters will restrict the task to only be assigned to one of the specified vehicles
  public var vehicleFilter: [Rideos_Dispatch_V3_Tasks_VehicleFilter] = []

  public var requiredPickupTimeWindow: Rideos_Dispatch_V3_Tasks_TimeWindow {
    get {return _requiredPickupTimeWindow ?? Rideos_Dispatch_V3_Tasks_TimeWindow()}
    set {_requiredPickupTimeWindow = newValue}
  }
  /// Returns true if `requiredPickupTimeWindow` has been explicitly set.
  public var hasRequiredPickupTimeWindow: Bool {return self._requiredPickupTimeWindow != nil}
  /// Clears the value of `requiredPickupTimeWindow`. Subsequent reads from it will return its default value.
  public mutating func clearRequiredPickupTimeWindow() {self._requiredPickupTimeWindow = nil}

  public var requiredDropoffTimeWindow: Rideos_Dispatch_V3_Tasks_TimeWindow {
    get {return _requiredDropoffTimeWindow ?? Rideos_Dispatch_V3_Tasks_TimeWindow()}
    set {_requiredDropoffTimeWindow = newValue}
  }
  /// Returns true if `requiredDropoffTimeWindow` has been explicitly set.
  public var hasRequiredDropoffTimeWindow: Bool {return self._requiredDropoffTimeWindow != nil}
  /// Clears the value of `requiredDropoffTimeWindow`. Subsequent reads from it will return its default value.
  public mutating func clearRequiredDropoffTimeWindow() {self._requiredDropoffTimeWindow = nil}

  public var poolingSetting: Rideos_Dispatch_V3_Tasks_TaskPoolingSetting = .fleetDefault

  /// Set the expected time that the `LOAD_RESOURCE` step will take for this trip. Will override the fleet optimization settings.
  public var expectedPickupServiceTimeDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _expectedPickupServiceTimeDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_expectedPickupServiceTimeDuration = newValue}
  }
  /// Returns true if `expectedPickupServiceTimeDuration` has been explicitly set.
  public var hasExpectedPickupServiceTimeDuration: Bool {return self._expectedPickupServiceTimeDuration != nil}
  /// Clears the value of `expectedPickupServiceTimeDuration`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedPickupServiceTimeDuration() {self._expectedPickupServiceTimeDuration = nil}

  /// Set the expected time that the `UNLOAD_RESOURCE` step will take for this trip. Will override the fleet optimization settings.
  public var expectedDropoffServiceTimeDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _expectedDropoffServiceTimeDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_expectedDropoffServiceTimeDuration = newValue}
  }
  /// Returns true if `expectedDropoffServiceTimeDuration` has been explicitly set.
  public var hasExpectedDropoffServiceTimeDuration: Bool {return self._expectedDropoffServiceTimeDuration != nil}
  /// Clears the value of `expectedDropoffServiceTimeDuration`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedDropoffServiceTimeDuration() {self._expectedDropoffServiceTimeDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _requiredPickupTimeWindow: Rideos_Dispatch_V3_Tasks_TimeWindow? = nil
  fileprivate var _requiredDropoffTimeWindow: Rideos_Dispatch_V3_Tasks_TimeWindow? = nil
  fileprivate var _expectedPickupServiceTimeDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _expectedDropoffServiceTimeDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

public struct Rideos_Dispatch_V3_Tasks_VehicleFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Force the task to be dispatched to the vehicle with this vehicle id
  public var vehicleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A time window defines the earliest time before the resource can be picked up or dropped off and the
/// latest allowable time before the resource needs to be picked up or dropped off. Vehicles that can pickup or dropoff
/// the resource before this window will still be assigned, but we will use the earliest pickup time in our ETA calculations for
/// optimization. Vehicles that can only pickup or dropoff the rider after this time will not be assigned.
/// If this value is not provided, the default fleet pickup/dropoff time window will be used.
public struct Rideos_Dispatch_V3_Tasks_TimeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var earliestTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _earliestTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_earliestTime = newValue}
  }
  /// Returns true if `earliestTime` has been explicitly set.
  public var hasEarliestTime: Bool {return self._earliestTime != nil}
  /// Clears the value of `earliestTime`. Subsequent reads from it will return its default value.
  public mutating func clearEarliestTime() {self._earliestTime = nil}

  public var latestTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _latestTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_latestTime = newValue}
  }
  /// Returns true if `latestTime` has been explicitly set.
  public var hasLatestTime: Bool {return self._latestTime != nil}
  /// Clears the value of `latestTime`. Subsequent reads from it will return its default value.
  public mutating func clearLatestTime() {self._latestTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _earliestTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _latestTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rideos_Dispatch_V3_Tasks_CreateTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var fleetID: String = String()

  public var taskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinition {
    get {return _taskDefinition ?? Rideos_Dispatch_V3_Tasks_TaskDefinition()}
    set {_taskDefinition = newValue}
  }
  /// Returns true if `taskDefinition` has been explicitly set.
  public var hasTaskDefinition: Bool {return self._taskDefinition != nil}
  /// Clears the value of `taskDefinition`. Subsequent reads from it will return its default value.
  public mutating func clearTaskDefinition() {self._taskDefinition = nil}

  public var metadata: Rideos_Dispatch_V3_Common_Metadata {
    get {return _metadata ?? Rideos_Dispatch_V3_Common_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Check to see whether there should be only 1 active task per requestor id
  public var checkOneActiveTaskPerRequestor: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _checkOneActiveTaskPerRequestor ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_checkOneActiveTaskPerRequestor = newValue}
  }
  /// Returns true if `checkOneActiveTaskPerRequestor` has been explicitly set.
  public var hasCheckOneActiveTaskPerRequestor: Bool {return self._checkOneActiveTaskPerRequestor != nil}
  /// Clears the value of `checkOneActiveTaskPerRequestor`. Subsequent reads from it will return its default value.
  public mutating func clearCheckOneActiveTaskPerRequestor() {self._checkOneActiveTaskPerRequestor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _taskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinition? = nil
  fileprivate var _metadata: Rideos_Dispatch_V3_Common_Metadata? = nil
  fileprivate var _checkOneActiveTaskPerRequestor: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Rideos_Dispatch_V3_Tasks_CreateTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

public struct Rideos_Dispatch_V3_Tasks_GetTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_GetTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

public struct Rideos_Dispatch_V3_Tasks_GetTasksByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_GetTasksByTimeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fleetID: String = String()

  /// Optional. Only tasks that terminated after this timestamp (exclusive) or are still active will be returned, defaults to now.
  public var terminatedAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _terminatedAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_terminatedAfter = newValue}
  }
  /// Returns true if `terminatedAfter` has been explicitly set.
  public var hasTerminatedAfter: Bool {return self._terminatedAfter != nil}
  /// Clears the value of `terminatedAfter`. Subsequent reads from it will return its default value.
  public mutating func clearTerminatedAfter() {self._terminatedAfter = nil}

  /// Optional. Only tasks that were created before this timestamp (inclusive) will be returned, defaults to now.
  public var createdBefore: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdBefore ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdBefore = newValue}
  }
  /// Returns true if `createdBefore` has been explicitly set.
  public var hasCreatedBefore: Bool {return self._createdBefore != nil}
  /// Clears the value of `createdBefore`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedBefore() {self._createdBefore = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _terminatedAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createdBefore: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rideos_Dispatch_V3_Tasks_GetTasksByCreationTimeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fleetID: String = String()

  /// The beginning of the time range (inclusive) from which to return data.
  public var createdAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAfter = newValue}
  }
  /// Returns true if `createdAfter` has been explicitly set.
  public var hasCreatedAfter: Bool {return self._createdAfter != nil}
  /// Clears the value of `createdAfter`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAfter() {self._createdAfter = nil}

  /// The end of the time range (exclusive) from which to return data.
  public var createdBefore: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdBefore ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdBefore = newValue}
  }
  /// Returns true if `createdBefore` has been explicitly set.
  public var hasCreatedBefore: Bool {return self._createdBefore != nil}
  /// Clears the value of `createdBefore`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedBefore() {self._createdBefore = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createdBefore: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rideos_Dispatch_V3_Tasks_GetTasksByRiderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var riderID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_GetTasksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tasks: Dictionary<String,Rideos_Dispatch_V3_Tasks_Task> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updatedTaskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate.OneOf_UpdatedTaskDefinition? = nil

  /// Updating operational tasks is not supported at the moment
  public var updatedPickupDropoffTask: Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate {
    get {
      if case .updatedPickupDropoffTask(let v)? = updatedTaskDefinition {return v}
      return Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate()
    }
    set {updatedTaskDefinition = .updatedPickupDropoffTask(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UpdatedTaskDefinition: Equatable {
    /// Updating operational tasks is not supported at the moment
    case updatedPickupDropoffTask(Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate)

  #if !swift(>=4.1)
    public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate.OneOf_UpdatedTaskDefinition, rhs: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate.OneOf_UpdatedTaskDefinition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.updatedPickupDropoffTask, .updatedPickupDropoffTask): return {
        guard case .updatedPickupDropoffTask(let l) = lhs, case .updatedPickupDropoffTask(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional
  public var updatedPickup: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _updatedPickup ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_updatedPickup = newValue}
  }
  /// Returns true if `updatedPickup` has been explicitly set.
  public var hasUpdatedPickup: Bool {return self._updatedPickup != nil}
  /// Clears the value of `updatedPickup`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedPickup() {self._updatedPickup = nil}

  /// Optional
  public var updatedDropoff: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _updatedDropoff ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_updatedDropoff = newValue}
  }
  /// Returns true if `updatedDropoff` has been explicitly set.
  public var hasUpdatedDropoff: Bool {return self._updatedDropoff != nil}
  /// Clears the value of `updatedDropoff`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedDropoff() {self._updatedDropoff = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedPickup: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
  fileprivate var _updatedDropoff: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
}

public struct Rideos_Dispatch_V3_Tasks_UpdateTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  /// Optional
  public var updatedMetadata: Rideos_Dispatch_V3_Common_Metadata {
    get {return _updatedMetadata ?? Rideos_Dispatch_V3_Common_Metadata()}
    set {_updatedMetadata = newValue}
  }
  /// Returns true if `updatedMetadata` has been explicitly set.
  public var hasUpdatedMetadata: Bool {return self._updatedMetadata != nil}
  /// Clears the value of `updatedMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedMetadata() {self._updatedMetadata = nil}

  /// Optional
  public var updatedTaskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate {
    get {return _updatedTaskDefinition ?? Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate()}
    set {_updatedTaskDefinition = newValue}
  }
  /// Returns true if `updatedTaskDefinition` has been explicitly set.
  public var hasUpdatedTaskDefinition: Bool {return self._updatedTaskDefinition != nil}
  /// Clears the value of `updatedTaskDefinition`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedTaskDefinition() {self._updatedTaskDefinition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedMetadata: Rideos_Dispatch_V3_Common_Metadata? = nil
  fileprivate var _updatedTaskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate? = nil
}

public struct Rideos_Dispatch_V3_Tasks_UpdateTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

public struct Rideos_Dispatch_V3_Tasks_ReplaceTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var replacementTaskID: String = String()

  /// One or both of new_pickup & new_dropoff should be specified
  public var newPickup: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _newPickup ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_newPickup = newValue}
  }
  /// Returns true if `newPickup` has been explicitly set.
  public var hasNewPickup: Bool {return self._newPickup != nil}
  /// Clears the value of `newPickup`. Subsequent reads from it will return its default value.
  public mutating func clearNewPickup() {self._newPickup = nil}

  public var newDropoff: Rideos_Dispatch_V3_Tasks_TaskLocation {
    get {return _newDropoff ?? Rideos_Dispatch_V3_Tasks_TaskLocation()}
    set {_newDropoff = newValue}
  }
  /// Returns true if `newDropoff` has been explicitly set.
  public var hasNewDropoff: Bool {return self._newDropoff != nil}
  /// Clears the value of `newDropoff`. Subsequent reads from it will return its default value.
  public mutating func clearNewDropoff() {self._newDropoff = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newPickup: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
  fileprivate var _newDropoff: Rideos_Dispatch_V3_Tasks_TaskLocation? = nil
}

public struct Rideos_Dispatch_V3_Tasks_ReplaceTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_CancelTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  /// If known, specify who or what cancelled the task
  public var source: Rideos_Dispatch_V3_Tasks_State_CancelSource = .unknown

  /// Optional description that will be stored in the task
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_CancelTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

public struct Rideos_Dispatch_V3_Tasks_RejectTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var rejectingVehicleID: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_RejectTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

public struct Rideos_Dispatch_V3_Tasks_UnassignTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  public var vehicleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_UnassignTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

public struct Rideos_Dispatch_V3_Tasks_CompleteStepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskID: String = String()

  /// List of steps to complete, in order.
  public var stepToComplete: [Rideos_Dispatch_V3_Tasks_StepToComplete] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rideos_Dispatch_V3_Tasks_StepToComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stepID: String = String()

  /// Optional - completion timestamp. If not set, the current timestamp will be used.
  public var timeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeOfCompletion ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeOfCompletion = newValue}
  }
  /// Returns true if `timeOfCompletion` has been explicitly set.
  public var hasTimeOfCompletion: Bool {return self._timeOfCompletion != nil}
  /// Clears the value of `timeOfCompletion`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfCompletion() {self._timeOfCompletion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfCompletion: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rideos_Dispatch_V3_Tasks_CompleteStepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var task: Rideos_Dispatch_V3_Tasks_Task {
    get {return _task ?? Rideos_Dispatch_V3_Tasks_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _task: Rideos_Dispatch_V3_Tasks_Task? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rideos.dispatch.v3.tasks"

extension Rideos_Dispatch_V3_Tasks_TaskPoolingSetting: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FLEET_DEFAULT"),
    2: .same(proto: "POOLED"),
  ]
}

extension Rideos_Dispatch_V3_Tasks_Task: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Task"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "fleet_id"),
    3: .standard(proto: "task_definition"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "creation_time"),
    6: .standard(proto: "termination_time"),
    7: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _taskID: String = String()
    var _fleetID: String = String()
    var _taskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinition? = nil
    var _metadata: Rideos_Dispatch_V3_Common_Metadata? = nil
    var _creationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _terminationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Rideos_Dispatch_V3_Tasks_State_TaskState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskID = source._taskID
      _fleetID = source._fleetID
      _taskDefinition = source._taskDefinition
      _metadata = source._metadata
      _creationTime = source._creationTime
      _terminationTime = source._terminationTime
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._taskID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._fleetID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._taskDefinition) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._creationTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._terminationTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._taskID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskID, fieldNumber: 1)
      }
      if !_storage._fleetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fleetID, fieldNumber: 2)
      }
      if let v = _storage._taskDefinition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._creationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._terminationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_Task, rhs: Rideos_Dispatch_V3_Tasks_Task) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskID != rhs_storage._taskID {return false}
        if _storage._fleetID != rhs_storage._fleetID {return false}
        if _storage._taskDefinition != rhs_storage._taskDefinition {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._creationTime != rhs_storage._creationTime {return false}
        if _storage._terminationTime != rhs_storage._terminationTime {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_TaskDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pickup_dropoff_task"),
    2: .standard(proto: "operational_task"),
    3: .standard(proto: "dispatch_parameters"),
    4: .standard(proto: "requestor_id"),
  ]

  fileprivate class _StorageClass {
    var _taskDefinition: Rideos_Dispatch_V3_Tasks_TaskDefinition.OneOf_TaskDefinition?
    var _dispatchParameters: Rideos_Dispatch_V3_Tasks_DispatchParameters? = nil
    var _requestorID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskDefinition = source._taskDefinition
      _dispatchParameters = source._dispatchParameters
      _requestorID = source._requestorID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Rideos_Dispatch_V3_Tasks_PickupDropoffTask?
          if let current = _storage._taskDefinition {
            try decoder.handleConflictingOneOf()
            if case .pickupDropoffTask(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._taskDefinition = .pickupDropoffTask(v)}
        }()
        case 2: try {
          var v: Rideos_Dispatch_V3_Tasks_OperationalTask?
          if let current = _storage._taskDefinition {
            try decoder.handleConflictingOneOf()
            if case .operationalTask(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._taskDefinition = .operationalTask(v)}
        }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dispatchParameters) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._requestorID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._taskDefinition {
      case .pickupDropoffTask?: try {
        guard case .pickupDropoffTask(let v)? = _storage._taskDefinition else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .operationalTask?: try {
        guard case .operationalTask(let v)? = _storage._taskDefinition else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case nil: break
      }
      if let v = _storage._dispatchParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._requestorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestorID, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TaskDefinition, rhs: Rideos_Dispatch_V3_Tasks_TaskDefinition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskDefinition != rhs_storage._taskDefinition {return false}
        if _storage._dispatchParameters != rhs_storage._dispatchParameters {return false}
        if _storage._requestorID != rhs_storage._requestorID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_TaskLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_id"),
    2: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_StringValue?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .stopID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .stopID(v)}
      }()
      case 2: try {
        var v: Rideos_Geo_V1_Position?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .position(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .stopID?: try {
      guard case .stopID(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .position?: try {
      guard case .position(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TaskLocation, rhs: Rideos_Dispatch_V3_Tasks_TaskLocation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_PickupDropoffTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickupDropoffTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unique_resource_pickup"),
    2: .standard(proto: "generic_resource_pickup"),
    3: .same(proto: "dropoff"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rideos_Dispatch_V3_Tasks_UniqueResourcePickup?
        if let current = self.pickupType {
          try decoder.handleConflictingOneOf()
          if case .uniqueResourcePickup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pickupType = .uniqueResourcePickup(v)}
      }()
      case 2: try {
        var v: Rideos_Dispatch_V3_Tasks_GenericResourcePickup?
        if let current = self.pickupType {
          try decoder.handleConflictingOneOf()
          if case .genericResourcePickup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pickupType = .genericResourcePickup(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dropoff) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pickupType {
    case .uniqueResourcePickup?: try {
      guard case .uniqueResourcePickup(let v)? = self.pickupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .genericResourcePickup?: try {
      guard case .genericResourcePickup(let v)? = self.pickupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._dropoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_PickupDropoffTask, rhs: Rideos_Dispatch_V3_Tasks_PickupDropoffTask) -> Bool {
    if lhs.pickupType != rhs.pickupType {return false}
    if lhs._dropoff != rhs._dropoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_UniqueResourcePickup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UniqueResourcePickup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pickup_location"),
    2: .standard(proto: "unique_resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pickupLocation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uniqueResource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pickupLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._uniqueResource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_UniqueResourcePickup, rhs: Rideos_Dispatch_V3_Tasks_UniqueResourcePickup) -> Bool {
    if lhs._pickupLocation != rhs._pickupLocation {return false}
    if lhs._uniqueResource != rhs._uniqueResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GenericResourcePickup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenericResourcePickup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "generic_resource_group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genericResourceGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._genericResourceGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GenericResourcePickup, rhs: Rideos_Dispatch_V3_Tasks_GenericResourcePickup) -> Bool {
    if lhs._genericResourceGroup != rhs._genericResourceGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_RiderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RiderInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contactInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contactInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_RiderInfo, rhs: Rideos_Dispatch_V3_Tasks_RiderInfo) -> Bool {
    if lhs._contactInfo != rhs._contactInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_OperationalTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationalTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stop"),
    2: .same(proto: "reason"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stop) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_OperationalTask, rhs: Rideos_Dispatch_V3_Tasks_OperationalTask) -> Bool {
    if lhs._stop != rhs._stop {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_OperationalTask.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REFUEL"),
    2: .same(proto: "REPAIR"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension Rideos_Dispatch_V3_Tasks_DispatchParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DispatchParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
    2: .standard(proto: "vehicle_filter"),
    3: .standard(proto: "required_pickup_time_window"),
    4: .standard(proto: "required_dropoff_time_window"),
    5: .standard(proto: "pooling_setting"),
    6: .standard(proto: "expected_pickup_service_time_duration"),
    7: .standard(proto: "expected_dropoff_service_time_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.vehicleFilter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requiredPickupTimeWindow) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._requiredDropoffTimeWindow) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.poolingSetting) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._expectedPickupServiceTimeDuration) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._expectedDropoffServiceTimeDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.vehicleFilter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vehicleFilter, fieldNumber: 2)
    }
    if let v = self._requiredPickupTimeWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._requiredDropoffTimeWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.poolingSetting != .fleetDefault {
      try visitor.visitSingularEnumField(value: self.poolingSetting, fieldNumber: 5)
    }
    if let v = self._expectedPickupServiceTimeDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._expectedDropoffServiceTimeDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_DispatchParameters, rhs: Rideos_Dispatch_V3_Tasks_DispatchParameters) -> Bool {
    if lhs._timeout != rhs._timeout {return false}
    if lhs.vehicleFilter != rhs.vehicleFilter {return false}
    if lhs._requiredPickupTimeWindow != rhs._requiredPickupTimeWindow {return false}
    if lhs._requiredDropoffTimeWindow != rhs._requiredDropoffTimeWindow {return false}
    if lhs.poolingSetting != rhs.poolingSetting {return false}
    if lhs._expectedPickupServiceTimeDuration != rhs._expectedPickupServiceTimeDuration {return false}
    if lhs._expectedDropoffServiceTimeDuration != rhs._expectedDropoffServiceTimeDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_VehicleFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehicleFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vehicleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.vehicleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_VehicleFilter, rhs: Rideos_Dispatch_V3_Tasks_VehicleFilter) -> Bool {
    if lhs.vehicleID != rhs.vehicleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_TimeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "earliest_time"),
    2: .standard(proto: "latest_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._earliestTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._latestTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._earliestTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._latestTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TimeWindow, rhs: Rideos_Dispatch_V3_Tasks_TimeWindow) -> Bool {
    if lhs._earliestTime != rhs._earliestTime {return false}
    if lhs._latestTime != rhs._latestTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_CreateTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "fleet_id"),
    3: .standard(proto: "task_definition"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "check_one_active_task_per_requestor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fleetID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._taskDefinition) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._checkOneActiveTaskPerRequestor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if !self.fleetID.isEmpty {
      try visitor.visitSingularStringField(value: self.fleetID, fieldNumber: 2)
    }
    if let v = self._taskDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._checkOneActiveTaskPerRequestor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_CreateTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_CreateTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.fleetID != rhs.fleetID {return false}
    if lhs._taskDefinition != rhs._taskDefinition {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._checkOneActiveTaskPerRequestor != rhs._checkOneActiveTaskPerRequestor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_CreateTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_CreateTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_CreateTaskResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_GetTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_GetTaskResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTasksByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTasksByIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.taskIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.taskIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTasksByIdRequest, rhs: Rideos_Dispatch_V3_Tasks_GetTasksByIdRequest) -> Bool {
    if lhs.taskIds != rhs.taskIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTasksByTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTasksByTimeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fleet_id"),
    2: .standard(proto: "terminated_after"),
    3: .standard(proto: "created_before"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fleetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._terminatedAfter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdBefore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fleetID.isEmpty {
      try visitor.visitSingularStringField(value: self.fleetID, fieldNumber: 1)
    }
    if let v = self._terminatedAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdBefore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTasksByTimeRequest, rhs: Rideos_Dispatch_V3_Tasks_GetTasksByTimeRequest) -> Bool {
    if lhs.fleetID != rhs.fleetID {return false}
    if lhs._terminatedAfter != rhs._terminatedAfter {return false}
    if lhs._createdBefore != rhs._createdBefore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTasksByCreationTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTasksByCreationTimeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fleet_id"),
    2: .standard(proto: "created_after"),
    3: .standard(proto: "created_before"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fleetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAfter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdBefore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fleetID.isEmpty {
      try visitor.visitSingularStringField(value: self.fleetID, fieldNumber: 1)
    }
    if let v = self._createdAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdBefore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTasksByCreationTimeRequest, rhs: Rideos_Dispatch_V3_Tasks_GetTasksByCreationTimeRequest) -> Bool {
    if lhs.fleetID != rhs.fleetID {return false}
    if lhs._createdAfter != rhs._createdAfter {return false}
    if lhs._createdBefore != rhs._createdBefore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTasksByRiderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTasksByRiderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rider_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.riderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.riderID.isEmpty {
      try visitor.visitSingularStringField(value: self.riderID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTasksByRiderRequest, rhs: Rideos_Dispatch_V3_Tasks_GetTasksByRiderRequest) -> Bool {
    if lhs.riderID != rhs.riderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_GetTasksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTasksResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Rideos_Dispatch_V3_Tasks_Task>.self, value: &self.tasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tasks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Rideos_Dispatch_V3_Tasks_Task>.self, value: self.tasks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_GetTasksResponse, rhs: Rideos_Dispatch_V3_Tasks_GetTasksResponse) -> Bool {
    if lhs.tasks != rhs.tasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskDefinitionUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_pickup_dropoff_task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate?
        if let current = self.updatedTaskDefinition {
          try decoder.handleConflictingOneOf()
          if case .updatedPickupDropoffTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.updatedTaskDefinition = .updatedPickupDropoffTask(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .updatedPickupDropoffTask(let v)? = self.updatedTaskDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate, rhs: Rideos_Dispatch_V3_Tasks_TaskDefinitionUpdate) -> Bool {
    if lhs.updatedTaskDefinition != rhs.updatedTaskDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickupDropoffTaskUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_pickup"),
    2: .standard(proto: "updated_dropoff"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updatedPickup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedDropoff) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._updatedPickup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updatedDropoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate, rhs: Rideos_Dispatch_V3_Tasks_PickupDropoffTaskUpdate) -> Bool {
    if lhs._updatedPickup != rhs._updatedPickup {return false}
    if lhs._updatedDropoff != rhs._updatedDropoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_UpdateTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "updated_metadata"),
    3: .standard(proto: "updated_task_definition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedMetadata) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updatedTaskDefinition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if let v = self._updatedMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updatedTaskDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_UpdateTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_UpdateTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs._updatedMetadata != rhs._updatedMetadata {return false}
    if lhs._updatedTaskDefinition != rhs._updatedTaskDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_UpdateTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_UpdateTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_UpdateTaskResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_ReplaceTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplaceTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "replacement_task_id"),
    3: .standard(proto: "new_pickup"),
    4: .standard(proto: "new_dropoff"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.replacementTaskID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPickup) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newDropoff) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if !self.replacementTaskID.isEmpty {
      try visitor.visitSingularStringField(value: self.replacementTaskID, fieldNumber: 2)
    }
    if let v = self._newPickup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._newDropoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_ReplaceTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_ReplaceTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.replacementTaskID != rhs.replacementTaskID {return false}
    if lhs._newPickup != rhs._newPickup {return false}
    if lhs._newDropoff != rhs._newDropoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_ReplaceTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplaceTaskResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_ReplaceTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_ReplaceTaskResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_CancelTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .same(proto: "source"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_CancelTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_CancelTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_CancelTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_CancelTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_CancelTaskResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_RejectTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RejectTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "rejecting_vehicle_id"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rejectingVehicleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if !self.rejectingVehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectingVehicleID, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_RejectTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_RejectTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.rejectingVehicleID != rhs.rejectingVehicleID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_RejectTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RejectTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_RejectTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_RejectTaskResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_UnassignTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnassignTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "vehicle_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vehicleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if !self.vehicleID.isEmpty {
      try visitor.visitSingularStringField(value: self.vehicleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_UnassignTaskRequest, rhs: Rideos_Dispatch_V3_Tasks_UnassignTaskRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.vehicleID != rhs.vehicleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_UnassignTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnassignTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_UnassignTaskResponse, rhs: Rideos_Dispatch_V3_Tasks_UnassignTaskResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_CompleteStepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompleteStepsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "step_to_complete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stepToComplete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if !self.stepToComplete.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stepToComplete, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_CompleteStepsRequest, rhs: Rideos_Dispatch_V3_Tasks_CompleteStepsRequest) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.stepToComplete != rhs.stepToComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_StepToComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StepToComplete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_id"),
    2: .standard(proto: "time_of_completion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stepID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeOfCompletion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stepID.isEmpty {
      try visitor.visitSingularStringField(value: self.stepID, fieldNumber: 1)
    }
    if let v = self._timeOfCompletion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_StepToComplete, rhs: Rideos_Dispatch_V3_Tasks_StepToComplete) -> Bool {
    if lhs.stepID != rhs.stepID {return false}
    if lhs._timeOfCompletion != rhs._timeOfCompletion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rideos_Dispatch_V3_Tasks_CompleteStepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompleteStepsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rideos_Dispatch_V3_Tasks_CompleteStepsResponse, rhs: Rideos_Dispatch_V3_Tasks_CompleteStepsResponse) -> Bool {
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
